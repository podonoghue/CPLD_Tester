/**
 * @file      pin_mapping.h (derived from MKL03Z4.usbdmHardware)
 * @version   1.2.0
 * @brief     Pin declarations for MKL03Z8VFG4
 *
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#ifndef PROJECT_HEADERS_PIN_MAPPING_H
#define PROJECT_HEADERS_PIN_MAPPING_H

#include <stddef.h>
#include "derivative.h"

#include "pcr.h"

/**
 * Namespace enclosing USBDM classes
 */
namespace USBDM {

/**
 * @addtogroup USBDM_Group USBDM Peripheral Interface
 * @brief Hardware Peripheral Interface and library
 * @{
 */
/* Template:_common_settings.xml */

   /**
    * @tparam  T  Type of comparison object (inferred)
    * @param   a  Left-hand object for comparison
    * @param   b  Right-hand object for comparison
    *
    * @return Smaller of a or b
    */
   template<class T> 
   constexpr T min(const T a, const T b) {
      return (b < a) ? b : a;
   }

   /**
    * @tparam  T  Type of comparison object (inferred)
    * @param   a  Left-hand object for comparison
    * @param   b  Right-hand object for comparison
    *
    * @return Larger of a or b
    */
   template<class T> 
   constexpr T max(const T a, const T b) {
      return (b > a) ? b : a;
   }

#if defined(PCC)

/** Dummy port information for pins without an associated PCR */
constexpr PortInfo  __attribute__((unused)) NoPortInfo {0, 0, static_cast<IRQn_Type>(-1)};

#if defined(PCC_PCC_PORTA_CGC_MASK)
/** Port information for PORTA*/
constexpr PortInfo  __attribute__((unused)) PortAInfo {PORTA_BasePtr, static_cast<uint32_t>(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTA)), PORTA_IRQn};
#endif

#if defined(PCC_PCC_PORTB_CGC_MASK)
/** Port information for PORTB*/
constexpr PortInfo  __attribute__((unused)) PortBInfo {PORTB_BasePtr, static_cast<uint32_t>(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTB)), PORTB_IRQn};
#endif

#if defined(PCC_PCC_PORTC_CGC_MASK)
/** Port information for PORTC*/
constexpr PortInfo  __attribute__((unused)) PortCInfo {PORTC_BasePtr, static_cast<uint32_t>(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTC)), PORTC_IRQn};
#endif

#if defined(PCC_PCC_PORTD_CGC_MASK)
/** Port information for PORTD*/
constexpr PortInfo  __attribute__((unused)) PortDInfo {PORTD_BasePtr, static_cast<uint32_t>(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTD)), PORTD_IRQn};
#endif

#if defined(PCC_PCC_PORTE_CGC_MASK)
/** Port information for PORTE*/
constexpr PortInfo  __attribute__((unused)) PortEInfo {PORTE_BasePtr, static_cast<uint32_t>(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTE)), PORTE_IRQn};
#endif

#if defined(PCC_PCC_PORTF_CGC_MASK)
/** Port information for PORTF*/
constexpr PortInfo  __attribute__((unused)) PortFInfo {PORTF_BasePtr, static_cast<uint32_t>(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTF)), PORTF_IRQn};
#endif

#if defined(PCC_PCC_PORTG_CGC_MASK)
/** Port information for PORTG*/
constexpr PortInfo  __attribute__((unused)) PortGInfo {PORTG_BasePtr, static_cast<uint32_t>(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTG)), PORTG_IRQn};
#endif

#else // defined(PCC)
/** Dummy port information for pins without an associated PCR */
constexpr PortInfo  __attribute__((unused)) NoPortInfo {0, 0, static_cast<IRQn_Type>(-1)};

#ifdef SIM_SCGC5_PORTA_MASK
/** Port information for PORTA */
#ifndef PORTA_IRQS
constexpr PortInfo  __attribute__((unused)) PortAInfo {PORTA_BasePtr, SIM_SCGC5_PORTA_MASK, (static_cast<IRQn_Type>(-1))};
#else
constexpr IRQn_Type PORTA_IRQS_AR[] = PORTA_IRQS;
constexpr PortInfo  __attribute__((unused)) PortAInfo {PORTA_BasePtr, SIM_SCGC5_PORTA_MASK, PORTA_IRQS_AR[0]};
#endif
#endif

#ifdef SIM_SCGC5_PORTB_MASK
/** Port information for PORTB */
#ifndef PORTB_IRQS
constexpr PortInfo  __attribute__((unused)) PortBInfo {PORTB_BasePtr, SIM_SCGC5_PORTB_MASK, (static_cast<IRQn_Type>(-1))};
#else
constexpr IRQn_Type PORTB_IRQS_AR[] = PORTB_IRQS;
constexpr PortInfo  __attribute__((unused)) PortBInfo {PORTB_BasePtr, SIM_SCGC5_PORTB_MASK, PORTB_IRQS_AR[0]};
#endif
#endif

#ifdef SIM_SCGC5_PORTC_MASK
/** Port information for PORTC */
#ifndef PORTC_IRQS
constexpr PortInfo  __attribute__((unused)) PortCInfo {PORTC_BasePtr, SIM_SCGC5_PORTC_MASK, (static_cast<IRQn_Type>(-1))};
#else
constexpr IRQn_Type PORTC_IRQS_AR[] = PORTC_IRQS;
constexpr PortInfo  __attribute__((unused)) PortCInfo {PORTC_BasePtr, SIM_SCGC5_PORTC_MASK, PORTC_IRQS_AR[0]};
#endif
#endif

#ifdef SIM_SCGC5_PORTD_MASK
/** Port information for PORTD */
#ifndef PORTD_IRQS
constexpr PortInfo  __attribute__((unused)) PortDInfo {PORTD_BasePtr, SIM_SCGC5_PORTD_MASK, (static_cast<IRQn_Type>(-1))};
#else
constexpr IRQn_Type PORTD_IRQS_AR[] = PORTD_IRQS;
constexpr PortInfo  __attribute__((unused)) PortDInfo {PORTD_BasePtr, SIM_SCGC5_PORTD_MASK, PORTD_IRQS_AR[0]};
#endif
#endif

#ifdef SIM_SCGC5_PORTE_MASK
/** Port information for PORTE */
#ifndef PORTE_IRQS
constexpr PortInfo  __attribute__((unused)) PortEInfo {PORTE_BasePtr, SIM_SCGC5_PORTE_MASK, (static_cast<IRQn_Type>(-1))};
#else
constexpr IRQn_Type PORTE_IRQS_AR[] = PORTE_IRQS;
constexpr PortInfo  __attribute__((unused)) PortEInfo {PORTE_BasePtr, SIM_SCGC5_PORTE_MASK, PORTE_IRQS_AR[0]};
#endif
#endif

#endif // defined(PCC)

/** Class to static check signal mapping is valid */
template<class Info, int signalNum> class CheckSignal {
   static_assert((signalNum<Info::numSignals), "Non-existent signal - Modify Configure.usbdm");
   static_assert((signalNum>=Info::numSignals)||(Info::info[signalNum].gpioBit != UNMAPPED_PCR), "Signal is not mapped to a pin - Modify Configure.usbdm");
   static_assert((signalNum>=Info::numSignals)||(Info::info[signalNum].gpioBit != INVALID_PCR),  "Signal doesn't exist in this device/package");
   static_assert((signalNum>=Info::numSignals)||((Info::info[signalNum].gpioBit == UNMAPPED_PCR)||(Info::info[signalNum].gpioBit == INVALID_PCR)||(Info::info[signalNum].gpioBit >= 0)), "Illegal signal");
};

/** Enables mapping of all allocated pins during startup using mapAllPins() */
static constexpr bool MAP_ALL_PINS = false;

/** Used to configure pin-mapping before 1st use of peripherals */
extern void mapAllPins();

/* END Template:_common_settings.xml */

/*
 * Peripheral Information Classes
 */
/**
 * @addtogroup OSC_Group OSC, Crystal Oscillator
 * @brief Abstraction for Crystal Oscillator
 * @{
 */
#define USBDM_OSC0_IS_DEFINED
/**
 * Peripheral information for OSC, Crystal Oscillator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Osc0Info {
public:
   // Template:osc0_mk

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = OSC0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile OSC_Type &osc() {
      return *reinterpret_cast<OSC_Type *>(baseAddress);
   }

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Frequency of OSC Clock or Crystal
   static constexpr uint32_t osc_clock = 32768UL;

   //! Frequency of 32K OSC Clock or Crystal (if applicable)
   static constexpr uint32_t osc32k_clock = 32768UL;

   //! Oscillator control register
   static constexpr uint32_t cr =
      OSC_CR_ERCLKEN(0)  | // External Reference Enable
      OSC_CR_EREFSTEN(0) | // External Reference Stop Enable
      OSC_CR_SCP(0);       // Oscillator load capacitance

   /**
    * Get OSC clock (internal, assumed available)
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static constexpr uint32_t getOscClock() {
      return osc_clock;
   }

   /**
    * Get OSC clock (external, gated by OSC_CR_ERCLKEN)
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static uint32_t getOscerClock() {
      return (osc().CR&OSC_CR_ERCLKEN_MASK)?osc_clock:0;
   }

   /**
    * Get OSC32KCLK clock
    *
    * @return Clock frequency as uint32_t in Hz
   
    * @note This clock is only available if a 32kHz crystal or external clock is used 
    */
   static uint32_t getOsc32kClock() {
      return osc32k_clock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: XTAL0                = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: EXTAL0               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group OSC_Group
 * @}
 */
/**
 * @addtogroup RTC_Group RTC, Real Time Clock
 * @brief Abstraction for Real Time Clock
 * @{
 */
#define USBDM_RTC_IS_DEFINED
/**
 * Peripheral information for RTC, Real Time Clock.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class RtcInfo {
public:
   // Template:rtc_wps_mkl03z4

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = RTC_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile RTC_Type &rtc() {
      return *reinterpret_cast<RTC_Type *>(baseAddress);
   }

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Frequency of RTC External Clock or Crystal
   static constexpr uint32_t rtcclk_clock = 32768UL;

   //! Oscillator control register
   static constexpr uint32_t cr =
      RTC_CR_OSCE(0) | // Enables 32kHz oscillator [RTC_32K]
      RTC_CR_CLKO(0) | // Disables RTC 32kHz Clock Output
      RTC_CR_UM(0)   | // Update Mode
      RTC_CR_SUP(0)  | // Supervisor access
      RTC_CR_WPE(0)  | // Wakeup Pin Enable
      RTC_CR_SCP(0);   // RTC Oscillator load capacitance

   //! RTC Time Compensation Register
   static constexpr uint32_t tcr =
      RTC_TCR_CIR(0) | // Compensation Interval Register
      RTC_TCR_TCR(0);  // Time Compensation Register

   //! RTC Lock Register
   static constexpr uint32_t lr =
      RTC_LR_LRL(1) | // Lock Register Lock
      RTC_LR_SRL(1) | // Status Register Lock 
      RTC_LR_CRL(1) | // Control Register Lock
      RTC_LR_TCL(1);  // Time Compensation Lock

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   //! Time for cold start (corrected for 12 leap years since 1970)
   static constexpr uint32_t coldStartTime = 
            ((((2017-1970)*365UL +
               (181) +
               (1+12-1))*24 +
              (12))*60 +
             (0))*60;
   /** 
    *  Enable clock to Rtc
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableRtcClock();
#else
      SIM->SCGC6 |= SIM_SCGC6_RTC_MASK;
#endif
   }

   /** 
    *  Disable clock to Rtc
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableRtcClock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_RTC_MASK;
#endif
   }

   /**
    * Get RTC clock frequency (internal, not masked by RTC_CR_CLKO)
    *
    * @return Clock frequency as uint32_t
    */
   static uint32_t getInternalClock() {
      // RTC uses OSC0 EXTAL/XTAL clock
      return (rtc().CR&RTC_CR_OSCE_MASK)?Osc0Info::osc_clock:0;
   }

   /**
    * Get RTC clock frequency (external, masked by RTC_CR_CLKO)
    *
    * @return Clock frequency as uint32_t
    */
   static uint32_t getExternalClock() {
      return (rtc().CR&RTC_CR_CLKO_MASK)?0:getInternalClock();
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   1: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   2: RTC_CLKOUT           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: RTC_CLKIN            = PTA5 (p5)                      */  { PortAInfo,  GPIOA_BasePtr,  5,       PORT_PCR_MUX(1)|defaultPcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTA_CLOCK_MASK);
#endif
      PORTA->GPCLR = pcrValue|PORT_PCR_MUX(1)|PORT_GPCLR_GPWE(0x0020UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTA_CLOCK_MASK);
#endif
      PORTA->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x20U);
   }

};

/** 
 * End group RTC_Group
 * @}
 */
/**
 * @addtogroup MCG_Group MCG, Multipurpose Clock Generator
 * @brief Abstraction for Multipurpose Clock Generator
 * @{
 */
#define USBDM_MCG_IS_DEFINED
/**
 * Peripheral information for MCG, Multipurpose Clock Generator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class McgInfo {
public:
   // Template:mcg_lite_32k

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = MCG_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile MCG_Type &mcg() {
      return *reinterpret_cast<MCG_Type *>(baseAddress);
   }

   enum ClockMode {
      ClockMode_None     = -1,
      ClockMode_LIRC_2M  = 0,
      ClockMode_LIRC_8M,
      ClockMode_HIRC_48M,
      ClockMode_EXT,
   };

   //! Frequency of Slow Internal Reference Clock [~2MHz]
   static constexpr uint32_t system_slow_lirc_clock = 2000000UL;

   //! Frequency of Fast Internal Reference Clock [~8MHz]
   static constexpr uint32_t system_fast_lirc_clock = 8000000UL;

   //! Frequency of High Speed Internal Reference Clock [~48MHz]
   static constexpr uint32_t system_hirc_clock      = 48000000UL;

   //! Structure for clock configurations
   struct ClockInfo {
      //! System Clock Divider Register 1
      const uint32_t clkdiv1;

      //! SIM SOPT2 - Clock selectors for various peripherals
      const uint32_t sopt2;

      //! Clock Mode
      const ClockMode clockMode:8;

      //! Control Register 1 - IRCLKEN, IREFSTEN, (-CLKS)
      const uint8_t c1;
      //! Control Register 2 - RANGE0, HGO0, EREFS0, IRCS
      const uint8_t c2;
      //! Status and Control Register - FCRDIV
      const uint8_t sc;
      //! Miscellaneous Control Register - HIRCEN, LIRC_DIV2 (-HIRCLPEN)
      const uint8_t mc;
   };

   /**
    * Get HIRC_CLK
    *
    * @return frequency in Hz as uint32_t
    */
   static uint32_t getMcgPClk() {
      if ((mcg().MC&MCG_MC_HIRCEN_MASK) || ((mcg().S&MCG_S_CLKST_MASK) == MCG_S_CLKST(0))) {
         return system_hirc_clock;
      }
      else {
         return 0;
      }
   }

   /**
    * Get LIRC_CLK
    *
    * @return frequency in Hz as uint32_t
    */
   static uint32_t getLircClk() {
      if ((mcg().C1&MCG_C1_IRCLKEN_MASK) || ((mcg().S&MCG_S_CLKST_MASK) == MCG_S_CLKST(1))) {
         if (mcg().C2&MCG_C2_IRCS_MASK) {
            return system_fast_lirc_clock;
         }
         else {
            return system_slow_lirc_clock;
         }
      }
      else {
         return 0;
      }
   }

   /**
    * Get LIRC_DIV1_CLK
    *
    * @return frequency in Hz as uint32_t
    */
   static uint32_t getLircDiv1Clk() {
      return getLircClk()/(1<<((mcg().SC&MCG_SC_FCRDIV_MASK)>>MCG_SC_FCRDIV_SHIFT));
   }
   
   /**
    * Get MCGIRCLK
    *
    * @return frequency in Hz as uint32_t
    */
   static uint32_t getMcgIrClock() {
      return getLircDiv1Clk()/(1<<((mcg().MC&MCG_MC_LIRC_DIV2_MASK)>>MCG_MC_LIRC_DIV2_SHIFT));
   }

   /**
    * Get MCGOUTCLK
    *
    * @return frequency in Hz as uint32_t
    */
   static uint32_t getMcgOutClock() {
      switch (mcg().S&MCG_S_CLKST_MASK) {
      case MCG_S_CLKST(0): // HIRC
         return getMcgPClk();
      case MCG_S_CLKST(1): // LIRC (IRC2Mz/IRC8Mz)/DIV1
         return getLircDiv1Clk();
      case MCG_S_CLKST(2): // EXT (IRC48MHz)
         return system_hirc_clock;
      default:
      case MCG_S_CLKST(3): // Reserved
         return 0;
      }
   }

};

/** 
 * End group MCG_Group
 * @}
 */
/**
 * @addtogroup SIM_Group SIM, System Integration Module
 * @brief Abstraction for System Integration Module
 * @{
 */
#define USBDM_SIM_IS_DEFINED
/**
 * Peripheral information for SIM, System Integration Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * LPUART0 Clock sources
    */
   enum SimLpuart0ClockSource {
      SimLpuart0ClockSource_Disabled   = SIM_SOPT2_LPUART0SRC(0), //!< Disabled
      SimLpuart0ClockSource_McgPClk    = SIM_SOPT2_LPUART0SRC(1), //!< MCGPCLK = IRC48M clock
      SimLpuart0ClockSource_OscerClk   = SIM_SOPT2_LPUART0SRC(2), //!< OSCERCLK clock
      SimLpuart0ClockSource_McgIrClk   = SIM_SOPT2_LPUART0SRC(3), //!< MCG Internal Reference clock
   };

   /**
    * TPM Clock sources
    */
   enum SimTpmClockSource {
      SimTpmClockSource_Disabled   = SIM_SOPT2_TPMSRC(0), //!< Disabled
      SimTpmClockSource_McgPClk    = SIM_SOPT2_TPMSRC(1), //!< MCGPCLK = IRC48M clock
      SimTpmClockSource_OscerClk   = SIM_SOPT2_TPMSRC(2), //!< OSCERCLK clock
      SimTpmClockSource_McgIrClk   = SIM_SOPT2_TPMSRC(3), //!< MCG Internal Reference clock (MCGIRCLK)
   };

   /**
    * Selects the ADC0 Trigger source in STOP and VLPS modes, or when ADC0 Alternative Trigger is active.
    */
   enum SimAdc0Trigger {
      SimAdc0Trigger_External     = SIM_SOPT7_ADC0TRGSEL(0),   //!< External Trigger Source
      SimAdc0Trigger_Cmp0         = SIM_SOPT7_ADC0TRGSEL(1),   //!< Comparator 0
      SimAdc0Trigger_Cmp1         = SIM_SOPT7_ADC0TRGSEL(2),   //!< Comparator 1 (if present)
      SimAdc0Trigger_3            = SIM_SOPT7_ADC0TRGSEL(3),   //!< Reserved
      SimAdc0Trigger_4            = SIM_SOPT7_ADC0TRGSEL(4),   //!< Reserved
      SimAdc0Trigger_5            = SIM_SOPT7_ADC0TRGSEL(5),   //!< Reserved
      SimAdc0Trigger_6            = SIM_SOPT7_ADC0TRGSEL(6),   //!< Reserved
      SimAdc0Trigger_7            = SIM_SOPT7_ADC0TRGSEL(7),   //!< Reserved
      SimAdc0Trigger_Tpm0         = SIM_SOPT7_ADC0TRGSEL(8),   //!< TPM0 Init and Ext Trigger Outputs
      SimAdc0Trigger_Tpm1         = SIM_SOPT7_ADC0TRGSEL(9),   //!< TPM1 Init and Ext Trigger Outputs
      SimAdc0Trigger_10           = SIM_SOPT7_ADC0TRGSEL(10),  //!< Reserved
      SimAdc0Trigger_11           = SIM_SOPT7_ADC0TRGSEL(11),  //!< Reserved
      SimAdc0Trigger_RtcAlarm     = SIM_SOPT7_ADC0TRGSEL(12),  //!< RTC Alarm
      SimAdc0Trigger_RtcSeconds   = SIM_SOPT7_ADC0TRGSEL(13),  //!< RTC Seconds
      SimAdc0Trigger_Lptrm        = SIM_SOPT7_ADC0TRGSEL(14),  //!< LPTMR
      SimAdc0Trigger_15           = SIM_SOPT7_ADC0TRGSEL(15),  //!< Reserved
   };

   /**
    * Selects the ADC0 trigger mode.
    * 
    *    _Tpm              - ADC is triggered by TPM. Pre-triggers are TPM channel 0 (A) and channel 1 (B)
    *    _Alt_PreTrigger_0 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
    *    _Alt_PreTrigger_1 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
    */
   enum SimAdc0TriggerMode {
      SimAdc0TriggerMode_Tpm               = SIM_SOPT7_ADC0ALTTRGEN(0),                              //!< TPM trigger
      SimAdc0TriggerMode_Alt_PreTrigger_0  = SIM_SOPT7_ADC0ALTTRGEN(1)|SIM_SOPT7_ADC0PRETRGSEL(0),   //!< Pre-trigger 0 = A (SC1[0])
      SimAdc0TriggerMode_Alt_PreTrigger_1  = SIM_SOPT7_ADC0ALTTRGEN(1)|SIM_SOPT7_ADC0PRETRGSEL(1),   //!< Pre-trigger 1 = B (SC1[1])
   };

class SimInfo {
public:
   // Template:sim_mkl03z4

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = SIM_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile SIM_Type &sim() {
      return *reinterpret_cast<SIM_Type *>(baseAddress);
   }

   //! System Options Register 1
   static constexpr uint32_t sopt1 = 
   #ifdef SIM_SOPT1_OSC32KOUT
      SIM_SOPT1_OSC32KOUT(0) |    // 32K oscillator clock out pin select
   #endif
      SIM_SOPT1_OSC32KSEL(0);     // 32K oscillator clock select

   /**
    * Get ERCLK32K clock frequency
    *
    * @return Clock frequency as a uint32_t in Hz
    */
   static uint32_t getErc32kClock() {
   
      switch(sim().SOPT1&SIM_SOPT1_OSC32KSEL_MASK) {
         default                     : return 0;
         case SIM_SOPT1_OSC32KSEL(0) : return Osc0Info::getOsc32kClock();
         case SIM_SOPT1_OSC32KSEL(2) : return RtcInfo::rtcclk_clock;
         case SIM_SOPT1_OSC32KSEL(3) : return 1000;
      }
   }

   /**
    * Get Peripheral clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getPeripheralClock() {
      return McgInfo::getMcgPClk();
   }

   /**
    * Set LPUART0 input clock source
    *
    * @param simLpuart0ClockSource Clock source for LPUART
    */
   static void setLpuart0Clock(SimLpuart0ClockSource simLpuart0ClockSource) {
      sim().SOPT2 = (sim().SOPT2&~SIM_SOPT2_LPUART0SRC_MASK) | simLpuart0ClockSource;
   }

   /**
    * Get LPUART0 input clock frequency
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getLpuart0Clock() {
      
      switch(sim().SOPT2&SIM_SOPT2_LPUART0SRC_MASK) {
         default:
         case SIM_SOPT2_LPUART0SRC(0): return 0;
         case SIM_SOPT2_LPUART0SRC(1): return McgInfo::getMcgPClk();
         case SIM_SOPT2_LPUART0SRC(2): return Osc0Info::getOscerClock();
         case SIM_SOPT2_LPUART0SRC(3): return McgInfo::getMcgIrClock();
      }
   }

   /**
    * Set TPM input clock source
    *
    * @param simTpmClockSource Clock source for TPM
    */
   static void setTpmClock(SimTpmClockSource simTpmClockSource) {
      sim().SOPT2 = (sim().SOPT2&~SIM_SOPT2_TPMSRC_MASK) | simTpmClockSource;
   }

   /**
    * Get TPM input clock frequency
    *
    * @return TPM input clock frequency as a uint32_t in Hz
    */
   static uint32_t getTpmClock() {
      switch(sim().SOPT2&SIM_SOPT2_TPMSRC_MASK) {
         default:
         case SIM_SOPT2_TPMSRC(0): return 0;
         case SIM_SOPT2_TPMSRC(1): return McgInfo::getMcgPClk();
         case SIM_SOPT2_TPMSRC(2): return Osc0Info::getOscerClock();
         case SIM_SOPT2_TPMSRC(3): return McgInfo::getMcgIrClock();
      }
   }

   //! System Options Register 2
   static constexpr uint32_t sopt2 = 
   #ifdef SIM_SOPT2_TRACECLKSEL
      SIM_SOPT2_TRACECLKSEL(-1) |      // Debug trace clock select
   #endif
   #ifdef SIM_SOPT2_TIMESRC
      SIM_SOPT2_TIMESRC(-1) |          // IEEE 1588 timestamp clock source select
   #endif
   #ifdef SIM_SOPT2_RMIISRC
      SIM_SOPT2_RMIISRC(-1) |          // Ethernet RMII clock source select
   #endif
   #ifdef SIM_SOPT2_SDHCSRC
         SIM_SOPT2_SDHCSRC(-1) |       // SDHC clock source select
   #endif
   #ifdef SIM_SOPT2_UART0SRC
      SIM_SOPT2_UART0SRC(-1) |         // UART0 clock source select
   #endif
   #ifdef SIM_SOPT2_LPUARTSRC
         SIM_SOPT2_LPUARTSRC(-1) |     // LPUART clock source select
   #endif
   #ifdef SIM_SOPT2_LPUART0SRC
         SIM_SOPT2_LPUART0SRC(1) |     // LPUART clock source select
   #endif
   #ifdef SIM_SOPT2_PTD7PAD
         SIM_SOPT2_PTD7PAD(-1) |       // PTD7 pad drive strength
   #endif
   #ifdef SIM_SOPT2_TPMSRC
         SIM_SOPT2_TPMSRC(3) |        // TPM clock source select
   #endif
   #ifdef SIM_SOPT2_USBSRC
         SIM_SOPT2_USBSRC(-1) |        // USB clock source select
   #endif
   #ifdef SIM_SOPT2_FBSL
         SIM_SOPT2_FBSL(-1) |          // FlexBus security level
   #endif
   #ifdef SIM_SOPT2_PLLFLLSEL
         SIM_SOPT2_PLLFLLSEL(-1)|      // PLL/FLL clock select
   #endif
   #ifdef SIM_SOPT2_RTCCLKOUTSEL
         SIM_SOPT2_RTCCLKOUTSEL(1) |  // RTC clock out select
   #endif
         SIM_SOPT2_CLKOUTSEL(2);      // CLKOUT pin clock source select

   //! System Options Register 4
   static constexpr uint32_t sopt4 = 
      SIM_SOPT4_TPM1CLKSEL(0)  |   // TPM 1 External Clock Pin Select
      SIM_SOPT4_TPM0CLKSEL(0)  |   // TPM 0 External Clock Pin Select
      SIM_SOPT4_TPM1CH0SRC(0);     // TPM 1 channel 0 input capture source select

   //! System Options Register 5
   static constexpr uint32_t sopt5 = 
      SIM_SOPT5_LPUART0ODE(0) |        // LPUART 0 Open Drain Enable
      SIM_SOPT5_LPUART0TXSRC(0) |      // LPUART 0 transmit data source select
      SIM_SOPT5_LPUART0RXSRC(0) |      // LPUART 0 receive data source select
      0;

   /**
    * Select the ADC0 Trigger source
    * 
    * If TPM is selected by SimAdc0Trigger then Pre-triggers are TPM channel 0 (A) and channel 1 (B),
    * otherwise Pre-trigger 0/1 is determined by this parameter.
    * For example, setAdc0Triggers(SimAdc0TriggerMode_Alt_PreTrigger_1, SimAdc0Trigger_PitCh0) will set the trigger source
    * to PIT channel 0 and conversion will use SC1[1]/R[1]. 
    *
    * @param[in] simAdc0TriggerMode Select ADC0 Trigger mode 
    * @param[in] simAdc0Trigger     Select the ADC0 Trigger source in STOP and VLPS modes, or when ADC0 Alternative Trigger is active.
    */
   static void setAdc0Triggers(SimAdc0TriggerMode simAdc0TriggerMode, SimAdc0Trigger simAdc0Trigger=SimAdc0Trigger_External) {
      sim().SOPT7 = (sim().SOPT7&~(SIM_SOPT7_ADC0TRGSEL_MASK|SIM_SOPT7_ADC0ALTTRGEN_MASK))|simAdc0Trigger|simAdc0TriggerMode;
   };

   //! System Options Register 7
   static constexpr uint32_t sopt7 = 
      SIM_SOPT7_ADC0ALTTRGEN(0) |    // ADC0 alternate trigger enable
      SIM_SOPT7_ADC0PRETRGSEL(0) |   // ADC0 pretrigger select
      SIM_SOPT7_ADC0TRGSEL(0);       // ADC0 trigger select

   /**
    * Initialise SIM registers
    */
   static void initRegs() {
   #ifdef SIM_SCGC4_USBOTG_MASK
      // The USB interface must be disabled for clock changes to have effect
      sim().SCGC4 &= ~SIM_SCGC4_USBOTG_MASK;
   #endif
   
      sim().SOPT1 = sopt1;
      // sim_sopt2_pllfllsel may also be altered by MCG clock code
      sim().SOPT2 = sopt2;
      sim().SOPT4 = sopt4;
      sim().SOPT5 = sopt5;
      sim().SOPT7 = sopt7;
   
   #ifdef SIM_CLKDIV2_USBDIV_MASK
      sim().CLKDIV2 = clkdiv2;
   #endif
   }

};

/** 
 * End group SIM_Group
 * @}
 */
/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Abstraction for Analogue Input
 * @{
 */
#define USBDM_ADC0_IS_DEFINED
/**
 * Peripheral information for ADC, Analogue Input.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
#ifndef USBDM_ADC_CLOCK_SOURCES_DEFINED
#define USBDM_ADC_CLOCK_SOURCES_DEFINED
   /**
    * ADC input clock source.
    */
   enum AdcClockSource {
      AdcClockSource_Bus      = ADC_CFG1_ADICLK(0), //!< Bus Clock
      AdcClockSource_Busdiv2  = ADC_CFG1_ADICLK(1), //!< Bus Clock / 2
      AdcClockSource_Alt      = ADC_CFG1_ADICLK(2), //!< Alternate clock (ALTCLK)
      AdcClockSource_Asynch   = ADC_CFG1_ADICLK(3), //!< Asynchronous clock (ADACK Internal ADC clock source)
      AdcClockSource_Default  = AdcClockSource_Asynch
   };
#endif

class Adc0Info {
public:
   // Template:adc0_mkl

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = ADC0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile ADC_Type &adc() {
      return *reinterpret_cast<ADC_Type *>(baseAddress);
   }

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = ADC0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeof(irqNums)/sizeof(irqNums[0]);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 1;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /**
    *  Get input clock frequency for ADC
    *  
    *  @param adcClockSource Clock source chosen for ADC
    *
    *  @return Frequency in Hz
    */
   static unsigned getInputClockFrequency(AdcClockSource adcClockSource) {
      switch (adcClockSource) {
         case AdcClockSource_Bus:
            return SystemBusClock;
         case AdcClockSource_Busdiv2:
            return SystemBusClock/2;
         case AdcClockSource_Alt:
            return  Osc0Info::getOscerClock();;
         case AdcClockSource_Asynch:
            return 2000000; // Actually varies with ADLPC/ADHSC
         default:
            return 0;
            break;
      }
   }

   /**
    *  Get input clock frequency for ADC
    *
    *  @return Frequency in Hz
    */
   static unsigned getInputClockFrequency() {
      return getInputClockFrequency(static_cast<AdcClockSource>(adc().CFG1 & ADC_CFG1_ADICLK_MASK));
   }

   //! Default resolution
   static constexpr uint32_t defaultAdcResolution = ADC_CFG1_MODE(2);

   //! Default value for ADCx_CFG1 register
   static constexpr uint32_t cfg1  = 
       ADC_CFG1_ADICLK(1)|
       ADC_CFG1_MODE(2)|
       ADC_CFG1_ADLSMP(0)|
       ADC_CFG1_ADIV(3)|
       ADC_CFG1_ADLPC(0);

   //! Default value for ADCx_CFG2 register
    static constexpr uint32_t cfg2  = 
       ADC_CFG2_MUXSEL_MASK | // Choose 'b' channels
       ADC_CFG2_ADLSTS(0)|
       ADC_CFG2_ADHSC(0)|
       ADC_CFG2_ADACKEN(0);

   //! Default value for ADCx_SC2 register
   static constexpr uint32_t sc2  =
       ADC_SC2_ACFE(0)|
       ADC_SC2_ACFGT(0)|
       ADC_SC2_ACREN(0)|
       ADC_SC2_REFSEL(0)|
       ADC_SC2_ADTRG(0);

   //! Default value for ADCx_CV1 register
   static constexpr uint32_t cv1  = 0;

   //! Default value for ADCx_CV2 register
   static constexpr uint32_t cv2  = 0;

   /** 
    *  Enable clock to Adc0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableAdc0Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_ADC0_MASK;
#endif
   }

   /** 
    *  Disable clock to Adc0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableAdc0Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_ADC0_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 16;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: ADC0_SE0             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: ADC0_SE1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: ADC0_SE2             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: ADC0_SE3             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   5: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   6: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   7: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   8: ADC0_SE8             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   9: ADC0_SE9             = PTB0 (p8)                      */  { PortBInfo,  GPIOB_BasePtr,  0,       PORT_PCR_MUX(0)|defaultPcrValue  },
         /*  10: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  11: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  12: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  13: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  14: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  15: ADC0_SE15            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTB_CLOCK_MASK);
#endif
      PORTB->GPCLR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x0001UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTB_CLOCK_MASK);
#endif
      PORTB->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x1U);
   }

};

/** 
 * End group ADC_Group
 * @}
 */
/**
 * @addtogroup CMP_Group CMP, Analogue Comparator
 * @brief Abstraction for Analogue Comparator
 * @{
 */
#define USBDM_CMP0_IS_DEFINED
/**
 * Peripheral information for CMP, Analogue Comparator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Cmp0Info {
public:
   // Template:cmp0_trigm

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = CMP0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile CMP_Type &cmp() {
      return *reinterpret_cast<CMP_Type *>(baseAddress);
   }

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Pin number in Info table for comparator output
   static constexpr int outputPin  = 8;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! CMP Control Register 0
   static constexpr uint32_t cr0 =
      CMP_CR0_FILTER_CNT(0)     | // Filter Sample Count
      CMP_CR0_HYSTCTR(0);         // Comparator hard block hysteresis control

   #ifndef CMP_CR1_TRIGM
   #define CMP_CR1_TRIGM(x) 0
   #endif

   //! CMP Control Register 1
   static constexpr uint32_t cr1 =
      CMP_CR1_SE(0)    | // Sample Enable
      CMP_CR1_WE(0)    | // Windowing Enable
      CMP_CR1_TRIGM(0) | // Trigger Mode Enable
      CMP_CR1_PMODE(0) | // Power mode Select
      CMP_CR1_INV(0)   | // Comparator Invert
      CMP_CR1_COS(0)   | // Comparator Output Select
      CMP_CR1_OPE(0);    // Comparator Output Pin Enable

   //! CMP Filter Period Register
   static constexpr uint32_t fpr =
      CMP_FPR_FILT_PER(0); // Filter Sample Period

   //! CMP Status and Control Register
   static constexpr uint32_t scr =
   #ifdef CMP_SCR_DMAEN
      CMP_SCR_DMAEN(0) | // DMA Enable Control
   #endif
      CMP_SCR_IER(0) | // Comparator Interrupt Enable Rising
      CMP_SCR_IEF(0);  // Comparator Interrupt Enable Falling

   //! DAC Control Register
   static constexpr uint32_t daccr =
      CMP_DACCR_VRSEL(0); // Supply Voltage Reference Source Select

   //! MUX Control Register
   static constexpr uint32_t muxcr =
      CMP_MUXCR_PSEL(0)| // Plus Input Mux Control
      CMP_MUXCR_MSEL(0); // Minus Input Mux Control

   /** 
    *  Enable clock to Cmp0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableCmp0Clock();
#else
      SIM->SCGC4 |= SIM_SCGC4_CMP0_MASK;
#endif
   }

   /** 
    *  Disable clock to Cmp0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableCmp0Clock();
#else
      SIM->SCGC4 &= ~SIM_SCGC4_CMP0_MASK;
#endif
   }

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = CMP0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeof(irqNums)/sizeof(irqNums[0]);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: CMP0_IN0             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: CMP0_IN1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: CMP0_IN2             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: CMP0_IN3             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   5: CMP0_IN5             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   7: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   8: CMP0_OUT             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group CMP_Group
 * @}
 */
/**
 * @addtogroup Control_Group CONTROL, Control
 * @brief Abstraction for Control
 * @{
 */
#define USBDM_CONTROL_IS_DEFINED
/**
 * Peripheral information for CONTROL, Control.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class ControlInfo {
public:
   // Template:control

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 6;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: SWD_CLK              = PTA0 (p14)                     */  { PortAInfo,  GPIOA_BasePtr,  0,       PORT_PCR_MUX(3)|defaultPcrValue  },
         /*   1: RESET_b              = PTA1 (p15)                     */  { PortAInfo,  GPIOA_BasePtr,  1,       PORT_PCR_MUX(3)|defaultPcrValue  },
         /*   2: SWD_DIO              = PTA2 (p16)                     */  { PortAInfo,  GPIOA_BasePtr,  2,       PORT_PCR_MUX(3)|defaultPcrValue  },
         /*   3: CLKOUT               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: NMI_b                = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: CLKOUT32K            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTA_CLOCK_MASK);
#endif
      PORTA->GPCLR = pcrValue|PORT_PCR_MUX(3)|PORT_GPCLR_GPWE(0x0007UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTA_CLOCK_MASK);
#endif
      PORTA->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x7U);
   }

};

/** 
 * End group Control_Group
 * @}
 */
/**
 * @addtogroup CONSOLE_Group Console, Console Interface
 * @brief Abstraction for Console Interface
 * @{
 */
/** 
 * End group CONSOLE_Group
 * @}
 */
/**
 * @addtogroup EXTERNALTRIGGER_Group ExternalTrigger, Shared Resources
 * @brief Abstraction for Shared Resources
 * @{
 */
#define USBDM_EXTERNALTRIGGER_IS_DEFINED
/**
 * Peripheral information for ExternalTrigger, Shared Resources.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class ExternaltriggerInfo {
public:
   // Template:externaltrigger

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue = 
      PORT_PCR_LK(0) |    // Lock Register
      PORT_PCR_DSE(0) |   // Drive Strength Enable
      PORT_PCR_ODE(0) |   // Open Drain Enable
      PORT_PCR_PFE(0) |   // Passive Filter Enable
      PORT_PCR_SRE(0) |   // Slew Rate Enable
      PORT_PCR_PS(0);     // Pull device

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: EXTRG_IN             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group EXTERNALTRIGGER_Group
 * @}
 */
/**
 * @addtogroup FTFA_Group FTFA, Flash Memory Module
 * @brief Abstraction for Flash Memory Module
 * @{
 */
#define USBDM_FTFA_IS_DEFINED
/**
 * Peripheral information for FTFA, Flash Memory Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class FtfaInfo {
public:
   // Template:ftfa

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = FTFA_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile FTFA_Type &ftfa() {
      return *reinterpret_cast<FTFA_Type *>(baseAddress);
   }

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = FTFA_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeof(irqNums)/sizeof(irqNums[0]);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /** 
    *  Enable clock to Ftfa
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableFtfaClock();
#else
      SIM->SCGC6 |= SIM_SCGC6_FTF_MASK;
#endif
   }

   /** 
    *  Disable clock to Ftfa
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableFtfaClock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_FTF_MASK;
#endif
   }

};

/** 
 * End group FTFA_Group
 * @}
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Abstraction for Digital Input/Output
 * @{
 */
#define USBDM_GPIOA_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioAInfo {
public:
   // Template:fgpioa_0xf8000000

   //! Describes the port/gpio
   static constexpr PinInfo pinInfo { PortAInfo, GPIOA_BasePtr, 0, GPIO_DEFAULT_PCR  };

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

};

#define USBDM_GPIOB_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioBInfo {
public:
   // Template:fgpioa_0xf8000000

   //! Describes the port/gpio
   static constexpr PinInfo pinInfo { PortBInfo, GPIOB_BasePtr, 0, GPIO_DEFAULT_PCR  };

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

};

/** 
 * End group GPIO_Group
 * @}
 */
/**
 * @addtogroup I2C_Group I2C, Inter-Integrated-Circuit Interface
 * @brief Abstraction for Inter-Integrated-Circuit Interface
 * @{
 */
#define USBDM_I2C0_IS_DEFINED
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class I2c0Info {
public:
   // Template:i2c0_mkl03

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = I2C0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile I2C_Type &i2c() {
      return *reinterpret_cast<I2C_Type *>(baseAddress);
   }

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = I2C_DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = I2C0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeof(irqNums)/sizeof(irqNums[0]);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   /** 
    *  Enable clock to I2c0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableI2c0Clock();
#else
      SIM->SCGC4 |= SIM_SCGC4_I2C0_MASK;
#endif
   }

   /** 
    *  Disable clock to I2c0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableI2c0Clock();
#else
      SIM->SCGC4 &= ~SIM_SCGC4_I2C0_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: I2C0_SCL             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: I2C0_SDA             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group I2C_Group
 * @}
 */
/**
 * @addtogroup LLWU_Group LLWU, Low-leakage Wake-up Unit
 * @brief Abstraction for Low-leakage Wake-up Unit
 * @{
 */
#define USBDM_LLWU_IS_DEFINED
/**
 * Peripheral information for LLWU, Low-leakage Wake-up Unit.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class LlwuInfo {
public:
   // Template:llwu_pe2_filt1

   // Module wake ups
   static constexpr uint8_t me =  
      LLWU_ME_WUME0(0) |  // LPTMR
      LLWU_ME_WUME1(0) |  // CMP0
      LLWU_ME_WUME4(0) |  // TSI0 (if present)
      LLWU_ME_WUME5(0) |  // RTC Alarm
      LLWU_ME_WUME6(0) |  //
      LLWU_ME_WUME7(0);   // RTC Seconds

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LLWU_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile LLWU_Type &llwu() {
      return *reinterpret_cast<LLWU_Type *>(baseAddress);
   }

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue = 
      PORT_PCR_LK(0) |    // Lock Register
      PORT_PCR_DSE(0) |   // Drive Strength Enable
      PORT_PCR_ODE(0) |   // Open Drain Enable
      PORT_PCR_PFE(0) |   // Passive Filter Enable
      PORT_PCR_SRE(0) |   // Slew Rate Enable
      PORT_PCR_PS(0);     // Pull device

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   // LLWU Pin Enable registers
   static constexpr uint8_t pe1 = 
      LLWU_PE1_WUPE0(0)|   // LLWUP 0
      LLWU_PE1_WUPE1(0)|   // LLWUP 1
      LLWU_PE1_WUPE2(0)|   // LLWUP 2
      LLWU_PE1_WUPE3(0);   // LLWUP 3 

   static constexpr uint8_t pe2 = 
      LLWU_PE2_WUPE4(0)|   // LLWUP 4
      LLWU_PE2_WUPE5(0)|   // LLWUP 5
      LLWU_PE2_WUPE6(0)|   // LLWUP 6
      LLWU_PE2_WUPE7(0);   // LLWUP 7 

   // Pin Filter 1 register
   static constexpr uint8_t filt1 = 
      LLWU_FILT_FILTE(0) |   // Digital Filter On External Pin
      LLWU_FILT_FILTSEL(0);  // Filter Pin Select

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = LLWU_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeof(irqNums)/sizeof(irqNums[0]);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   1: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   2: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   3: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   4: LLWU_P4              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   6: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   7: LLWU_P7              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group LLWU_Group
 * @}
 */
/**
 * @addtogroup LPTMR_Group LPTMR, Low Power Timer
 * @brief Abstraction for Low Power Timer
 * @{
 */
#define USBDM_LPTMR0_IS_DEFINED
/**
 * Peripheral information for LPTMR, Low Power Timer.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Lptmr0Info {
public:
   // Template:lptmr0

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LPTMR0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile LPTMR_Type &lptmr() {
      return *reinterpret_cast<LPTMR_Type *>(baseAddress);
   }

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue = 
      PORT_PCR_LK(0) |    // Lock Register
      PORT_PCR_DSE(0) |   // Drive Strength Enable
      PORT_PCR_ODE(0) |   // Open Drain Enable
      PORT_PCR_PFE(0) |   // Passive Filter Enable
      PORT_PCR_SRE(0) |   // Slew Rate Enable
      PORT_PCR_PS(0);     // Pull device

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Default Timer Compare value
   static constexpr uint32_t cmr = 65535;

   //! Default PSR value
   static constexpr uint32_t psr = 
      LPTMR_PSR_PRESCALE(0)|
      LPTMR_PSR_PBYP(0)|
      LPTMR_PSR_PCS(0);

   //! Default CSR value
   static constexpr uint32_t csr = 
      LPTMR_CSR_TIE(0)|
      LPTMR_CSR_TMS(0)|
      LPTMR_CSR_TFC(0)|
      LPTMR_CSR_TPP(0)|
      LPTMR_CSR_TPS(0);

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = LPTMR0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeof(irqNums)/sizeof(irqNums[0]);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as an uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(lptmr().PSR&LPTMR_PSR_PCS_MASK) {
      default:
      case LPTMR_PSR_PCS(0): return McgInfo::getMcgIrClock();
      case LPTMR_PSR_PCS(1): return SystemLpoClock;
      case LPTMR_PSR_PCS(2): return SimInfo::getErc32kClock();
      case LPTMR_PSR_PCS(3): return Osc0Info::getOscerClock();
      }
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a float in Hz
    */
   static float getClockFrequencyF() {
   
      float freq = getInputClockFrequency();
      if (lptmr().PSR&LPTMR_PSR_PBYP_MASK) {
         return freq;
      }
      return freq/(1<<(((lptmr().PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getClockFrequency() {
   
      uint32_t freq = getInputClockFrequency();
      if (lptmr().PSR&LPTMR_PSR_PBYP_MASK) {
         return freq;
      }
      return freq/(1<<(((lptmr().PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
   }

   /** 
    *  Enable clock to Lptmr0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableLptmr0Clock();
#else
      SIM->SCGC5 |= SIM_SCGC5_LPTMR_MASK;
#endif
   }

   /** 
    *  Disable clock to Lptmr0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableLptmr0Clock();
#else
      SIM->SCGC5 &= ~SIM_SCGC5_LPTMR_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   1: LPTMR0_ALT1          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: LPTMR0_ALT2          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: LPTMR0_ALT3          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group LPTMR_Group
 * @}
 */
/**
 * @addtogroup LPUART_Group LPUART, Low Power Universal Asynchronous Receiver/Transmitter
 * @brief Abstraction for Low Power Universal Asynchronous Receiver/Transmitter
 * @{
 */
#define USBDM_LPUART0_IS_DEFINED
/**
 * Peripheral information for LPUART, Low Power Universal Asynchronous Receiver/Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Lpuart0Info {
public:
   // Template:lpuart0_mkl03

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LPUART0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile LPUART_Type &lpuart() {
      return *reinterpret_cast<LPUART_Type *>(baseAddress);
   }

   //! Number of samples per bit
   static constexpr uint32_t oversampleRatio = 8;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = LPUART0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeof(irqNums)/sizeof(irqNums[0]);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   //! Default Baud rate used if not explicitly given
   static constexpr uint32_t defaultBaudRate = 115200;

   //! Default buffer size for receive queue when interrupt driven
   static constexpr unsigned receiveBufferSize = 50;

   //! Default buffer size for transmit queue when interrupt driven
   static constexpr unsigned transmitBufferSize = 50;

#if defined(PCC_PCC_LPUART0_CGC_MASK)
   //! Default clock source
   static constexpr PccDiv2Clock defaultClockSource = PccDiv2Clock_Firc;

   /**
    * Set LPUART0 input clock source.
    *
    * @param pccDiv2Clock Clock source selection
    *
    * @note This peripheral uses the DIV2 peripheral clocks e.g. SOSCDIV2_CLK 
    * @note The peripheral bus clock will be disabled before changing the 
            clock and is left disabled.
    */
   static void setClockSource(PccDiv2Clock pccDiv2Clock) {
      PccInfo::setLpuart0ClockSource(pccDiv2Clock);
   }
#endif

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getClockFrequency() {
#if defined(PCC_PCC_LPUART0_CGC_MASK)
      return PccInfo::getLpuart0Frequency();
   #elif defined(SIM_SOPT2_LPUART0SRC_MASK)
      return SimInfo::getLpuart0Clock();
   #else
      return SimInfo::getLpuartClock();
#endif
   }

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /** 
    *  Enable clock to Lpuart0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableLpuart0Clock();
#else
      SIM->SCGC5 |= SIM_SCGC5_LPUART0_MASK;
#endif
   }

   /** 
    *  Disable clock to Lpuart0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableLpuart0Clock();
#else
      SIM->SCGC5 &= ~SIM_SCGC5_LPUART0_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: LPUART0_TX           = PTA3 (p3)                      */  { PortAInfo,  GPIOA_BasePtr,  3,       PORT_PCR_MUX(4)|defaultPcrValue  },
         /*   1: LPUART0_RX           = PTA4 (p4)                      */  { PortAInfo,  GPIOA_BasePtr,  4,       PORT_PCR_MUX(4)|defaultPcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTA_CLOCK_MASK);
#endif
      PORTA->GPCLR = pcrValue|PORT_PCR_MUX(4)|PORT_GPCLR_GPWE(0x0018UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTA_CLOCK_MASK);
#endif
      PORTA->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x18U);
   }

};

/** 
 * End group LPUART_Group
 * @}
 */
/**
 * @addtogroup PMC_Group PMC, Power Management Controller
 * @brief Abstraction for Power Management Controller
 * @{
 */
#define USBDM_PMC_IS_DEFINED
/**
 * Peripheral information for PMC, Power Management Controller.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PmcInfo {
public:
   // Template:pmc_mk

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = PMC_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile PMC_Type &pmc() {
      return *reinterpret_cast<PMC_Type *>(baseAddress);
   }

   //! Default value for Low Voltage Detect Status And Control 1 register
   static constexpr uint32_t pmc_lvdsc1  = 
   #ifdef PMC_LVDSC1_LVDV
      PMC_LVDSC1_LVDV(0)   | // Low-Voltage Detect Voltage Select
   #endif
      PMC_LVDSC1_LVDIE(0) | // Low-Voltage Detect Interrupt Enable
      PMC_LVDSC1_LVDRE(0);  // Low-Voltage Detect Reset Enable

   //! Default value for Low Voltage Detect Status And Control 2 register
   static constexpr uint32_t pmc_lvdsc2  = 
   #ifdef PMC_LVDSC2_LVWV
      PMC_LVDSC2_LVWV(0)   | // Low-Voltage Warning Voltage Select
   #endif
      PMC_LVDSC2_LVWIE(0);  // Low-Voltage Warning Interrupt Enable

   #ifdef PMC_REGSC_BGEN
   //! Default value for Regulator Status And Control register
   static constexpr uint32_t pmc_regsc  = 
      PMC_REGSC_BGEN(0) | // Bandgap Enable In VLPx Operation
      PMC_REGSC_BGBE(0);  // Bandgap Buffer Enable   

   #endif
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = PMC_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeof(irqNums)/sizeof(irqNums[0]);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

};

/** 
 * End group PMC_Group
 * @}
 */
/**
 * @addtogroup Power_Group POWER, Power
 * @brief Abstraction for Power
 * @{
 */
#define USBDM_POWER_IS_DEFINED
/**
 * Peripheral information for POWER, Power.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PowerInfo {
public:
   // Template:power

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: VDD                  = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: VSS                  = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

};

/** 
 * End group Power_Group
 * @}
 */
/**
 * @addtogroup RCM_Group RCM, Reset Control Module
 * @brief Abstraction for Reset Control Module
 * @{
 */
#define USBDM_RCM_IS_DEFINED
/**
 * Peripheral information for RCM, Reset Control Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class RcmInfo {
public:
   // Template:rcm_mkl03z4

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = RCM_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile RCM_Type &rcm() {
      return *reinterpret_cast<RCM_Type *>(baseAddress);
   }

   //! Reset Pin Filter Control Register
   static constexpr uint8_t rcm_rpfc = 
      RCM_RPFC_RSTFLTSS(0)|   // Reset pin filter select in stop mode
      RCM_RPFC_RSTFLTSRW(0);  // Reset pin filter select in run and wait modes

   //! Reset pin filter bus clock select
   static constexpr uint8_t rcm_rpfw = 
      RCM_RPFW_RSTFLTSEL(0); 

};

/** 
 * End group RCM_Group
 * @}
 */
/**
 * @addtogroup SMC_Group SMC, System Mode Controller
 * @brief Abstraction for System Mode Controller
 * @{
 */
#define USBDM_SMC_IS_DEFINED
/**
 * Peripheral information for SMC, System Mode Controller.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class SmcInfo {
public:
   // Template:smc_lpopo_mkl03z4

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = SMC_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile SMC_Type &smc() {
      return *reinterpret_cast<SMC_Type *>(baseAddress);
   }

   // Power Mode Protection Register
   static constexpr uint8_t pmprot =  
      SMC_PMPROT_AVLP(1) |  // Allow very low power modes
      SMC_PMPROT_AVLLS(1);  // Allow very low leakage stop mode

   // VLLS Control Register
   static constexpr uint8_t stopctrl =  
#ifdef SMC_STOPCTRL_PSTOPO
      SMC_STOPCTRL_PSTOPO(0) |  // Partial Stop Option (if present)
#endif

      SMC_STOPCTRL_PORPO(0) |  // POR Power Option
#ifdef SMC_STOPCTRL_LPOPO
      SMC_STOPCTRL_LPOPO(0) |  // POR Power Option (if present)
#endif

      SMC_STOPCTRL_LLSM(0);   // LLS or VLLS Mode Control

};

/** 
 * End group SMC_Group
 * @}
 */
/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief Abstraction for Serial Peripheral Interface
 * @{
 */
#define USBDM_SPI0_IS_DEFINED
/**
 * Peripheral information for SPI, Serial Peripheral Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Spi0Info {
public:
   // Template:spi0_mkl_8bit

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = SPI0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile SPI_Type &spi() {
      return *reinterpret_cast<SPI_Type *>(baseAddress);
   }

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue = 
      PORT_PCR_LK(0) |    // Lock Register
      PORT_PCR_DSE(0) |   // Drive Strength Enable
      PORT_PCR_ODE(0) |   // Open Drain Enable
      PORT_PCR_PFE(0) |   // Passive Filter Enable
      PORT_PCR_SRE(0) |   // Slew Rate Enable
      PORT_PCR_PS(0);     // Pull device

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = SPI0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeof(irqNums)/sizeof(irqNums[0]);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /** 
    *  Enable clock to Spi0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableSpi0Clock();
#else
      SIM->SCGC4 |= SIM_SCGC4_SPI0_MASK;
#endif
   }

   /** 
    *  Disable clock to Spi0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableSpi0Clock();
#else
      SIM->SCGC4 &= ~SIM_SCGC4_SPI0_MASK;
#endif
   }

   //! Default communication mode: order, clock phase and clock polarity
   static constexpr uint8_t modeValue = 
      SPI_C1_LSBFE(0)| // LSB or MSB first
      SPI_C1_MODE(0);  // Mode (CPOL+CPHA)

   static uint32_t getClockFrequency() {
      return SystemBusClock;
   }

   //! Default speed (Hz)
   static constexpr uint32_t speed = 
      10000000;

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: SPI0_SCK             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: SPI0_MISO            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: SPI0_MOSI            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: SPI0_SS_b            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group SPI_Group
 * @}
 */
/**
 * @addtogroup TPM_Group TPM, PWM, Input capture and Output compare
 * @brief Abstraction for PWM, Input capture and Output compare
 * @{
 */
#define USBDM_TPM_IS_DEFINED
/**
 * Peripheral information for TPM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class TpmInfo {
public:
   // Template:tpm

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue = 
      PORT_PCR_LK(0) |    // Lock Register
      PORT_PCR_DSE(0) |   // Drive Strength Enable
      PORT_PCR_ODE(0) |   // Open Drain Enable
      PORT_PCR_PFE(0) |   // Passive Filter Enable
      PORT_PCR_SRE(0) |   // Slew Rate Enable
      PORT_PCR_PS(0);     // Pull device

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: TPM_CLKIN0           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: TPM_CLKIN1           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_TPM0_IS_DEFINED
/**
 * Peripheral information for TPM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Tpm0Info {
public:
   // Template:tpm0_2ch_dma

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = TPM0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile TPM_Type &tpm() {
      return *reinterpret_cast<TPM_Type *>(baseAddress);
   }

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue = 
      PORT_PCR_LK(0) |    // Lock Register
      PORT_PCR_DSE(0) |   // Drive Strength Enable
      PORT_PCR_ODE(0) |   // Open Drain Enable
      PORT_PCR_PFE(0) |   // Passive Filter Enable
      PORT_PCR_SRE(0) |   // Slew Rate Enable
      PORT_PCR_PS(0);     // Pull device

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Timer external input frequency 
   static constexpr uint32_t tpmExternalClock =  0;

   //! Default Timer Modulo
   static constexpr uint32_t modulo =TPM_MOD_MOD(9999);

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       TPM_SC_CPWMS(0)|  // Centre-Aligned PWM Select
       TPM_SC_CMOD(1) |  // Clock Mode Selection
       TPM_SC_TOIE(0)|   // Timer Overflow Interrupt Enable
       TPM_SC_PS(2);     // Prescale Factor Selection 

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = TPM0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeof(irqNums)/sizeof(irqNums[0]);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 1;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /** 
    *  Enable clock to Tpm0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableTpm0Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_TPM0_MASK;
#endif
   }

   /** 
    *  Disable clock to Tpm0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableTpm0Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_TPM0_MASK;
#endif
   }

   /** Minimum resolution for PWM interval */
   static constexpr uint32_t minimumResolution=100;

   /** Minimum usable interval in ticks */      
   static constexpr uint32_t minimumInterval=20;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(tpm().SC&TPM_SC_CMOD_MASK) {
      default:
      case TPM_SC_CMOD(0): return 0;
      case TPM_SC_CMOD(1): return SimInfo::getTpmClock();
      case TPM_SC_CMOD(2): return tpmExternalClock;
      case TPM_SC_CMOD(3): return 0;
      }
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: TPM0_CH0             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: TPM0_CH1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_TPM1_IS_DEFINED
/**
 * Peripheral information for TPM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Tpm1Info {
public:
   // Template:tpm0_2ch_dma

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = TPM1_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile TPM_Type &tpm() {
      return *reinterpret_cast<TPM_Type *>(baseAddress);
   }

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue = 
      PORT_PCR_LK(0) |    // Lock Register
      PORT_PCR_DSE(0) |   // Drive Strength Enable
      PORT_PCR_ODE(0) |   // Open Drain Enable
      PORT_PCR_PFE(0) |   // Passive Filter Enable
      PORT_PCR_SRE(0) |   // Slew Rate Enable
      PORT_PCR_PS(0);     // Pull device

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Timer external input frequency 
   static constexpr uint32_t tpmExternalClock =  0;

   //! Default Timer Modulo
   static constexpr uint32_t modulo =TPM_MOD_MOD(249);

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       TPM_SC_CPWMS(0)|  // Centre-Aligned PWM Select
       TPM_SC_CMOD(1) |  // Clock Mode Selection
       TPM_SC_TOIE(0)|   // Timer Overflow Interrupt Enable
       TPM_SC_PS(4);     // Prescale Factor Selection 

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = TPM1_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeof(irqNums)/sizeof(irqNums[0]);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /** 
    *  Enable clock to Tpm1
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableTpm1Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_TPM1_MASK;
#endif
   }

   /** 
    *  Disable clock to Tpm1
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableTpm1Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_TPM1_MASK;
#endif
   }

   /** Minimum resolution for PWM interval */
   static constexpr uint32_t minimumResolution=100;

   /** Minimum usable interval in ticks */      
   static constexpr uint32_t minimumInterval=20;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(tpm().SC&TPM_SC_CMOD_MASK) {
      default:
      case TPM_SC_CMOD(0): return 0;
      case TPM_SC_CMOD(1): return SimInfo::getTpmClock();
      case TPM_SC_CMOD(2): return tpmExternalClock;
      case TPM_SC_CMOD(3): return 0;
      }
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: TPM1_CH0             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: TPM1_CH1             = PTB5 (p13)                     */  { PortBInfo,  GPIOB_BasePtr,  5,       PORT_PCR_MUX(2)|defaultPcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTB_CLOCK_MASK);
#endif
      PORTB->GPCLR = pcrValue|PORT_PCR_MUX(2)|PORT_GPCLR_GPWE(0x0020UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTB_CLOCK_MASK);
#endif
      PORTB->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x20U);
   }

};

/** 
 * End group TPM_Group
 * @}
 */
/**
 * @addtogroup VREF_Group VREF, Voltage Reference
 * @brief Abstraction for Voltage Reference
 * @{
 */
#define USBDM_VREF_IS_DEFINED
/**
 * Peripheral information for VREF, Voltage Reference.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class VrefInfo {
public:
   // Template:vref_c

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = VREF_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile VREF_Type &vref() {
      return *reinterpret_cast<VREF_Type *>(baseAddress);
   }

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   static constexpr uint8_t vref_trm = 
       VREF_TRM_CHOPEN(1) | // Chop oscillator enable
       VREF_TRM_TRIM(32);   // Trim bits 

   static constexpr uint8_t vref_sc = 
       VREF_SC_VREFEN(1) |   // Internal Voltage Reference enable
       VREF_SC_REGEN(1) |    // Regulator enable
       VREF_SC_ICOMPEN(1) |  // Second order curvature compensation enable
       VREF_SC_MODE_LV(1);   // Buffer Mode selection 

   /** 
    *  Enable clock to Vref
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableVrefClock();
#else
      SIM->SCGC4 |= SIM_SCGC4_VREF_MASK;
#endif
   }

   /** 
    *  Disable clock to Vref
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableVrefClock();
#else
      SIM->SCGC4 &= ~SIM_SCGC4_VREF_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: VREF_OUT             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group VREF_Group
 * @}
 */
/** 
 * End group USBDM_Group
 * @}
 */

} // End namespace USBDM


#include "adc.h"
#include "tpm.h"
#include "gpio.h"

/**
 * Namespace enclosing USBDM classes
 */
namespace USBDM {

/**
 * @addtogroup USBDM_Group USBDM Peripheral Interface
 * @brief Hardware Peripheral Interface and library
 * @{
 */
/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Abstraction for Analogue Input
 * @{
 */
using Adc_p8               = const USBDM::Adc0::Channel<9>;
/** 
 * End group ADC_Group
 * @}
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Abstraction for Digital Input/Output
 * @{
 */
using Gpio_p5              = const USBDM::GpioA<5>;
using Gpio_p9              = const USBDM::GpioB<1>;
using Gpio_p12             = const USBDM::GpioB<4>;
/** 
 * End group GPIO_Group
 * @}
 */
/**
 * @addtogroup TPM_Group TPM, PWM, Input capture and Output compare
 * @brief Abstraction for PWM, Input capture and Output compare
 * @{
 */
using Tpm_p13              = const USBDM::Tpm1::Channel<1>;
/** 
 * End group TPM_Group
 * @}
 */
/** 
 * End group USBDM_Group
 * @}
 */

} // End namespace USBDM

/**
 *
 * @page PinSummary Pin Mapping
 *
 * @section PinsByPinName Pins by Pin Name
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  PTA0                     | SWD_CLK                                     | p14                       | SWD_CLK       
 *  PTA1                     | RESET_b                                     | p15                       | RESET_b       
 *  PTA2                     | SWD_DIO                                     | p16                       | SWD_DIO       
 *  PTA3                     | LPUART0_TX                                  | p3                        | Debug_Tx       
 *  PTA4                     | LPUART0_RX                                  | p4                        | Debug_Rx       
 *  PTA5                     | GPIOA_5/RTC_CLKIN                           | p5                        | TVdd_Status       
 *  PTA6                     | -                                           | p6                        | -       
 *  PTA7                     | -                                           | p7                        | -       
 *  PTB0                     | ADC0_SE9                                    | p8                        | TVdd_Sample       
 *  PTB1                     | GPIOB_1                                     | p9                        | TVdd_Enable       
 *  PTB2                     | -                                           | p10                       | -       
 *  PTB3                     | -                                           | p11                       | -       
 *  PTB4                     | GPIOB_4                                     | p12                       | Power_Button       
 *  PTB5                     | TPM1_CH1                                    | p13                       | Clock       
 *  VDD                      | -                                           | p1                        | -       
 *  VSS                      | -                                           | p2                        | -       
 *
 *
 * @section PinsByLocation Pins by Location
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  VDD                      | -                                           | p1                        | -       
 *  VSS                      | -                                           | p2                        | -       
 *  PTA3                     | LPUART0_TX                                  | p3                        | Debug_Tx       
 *  PTA4                     | LPUART0_RX                                  | p4                        | Debug_Rx       
 *  PTA5                     | GPIOA_5/RTC_CLKIN                           | p5                        | TVdd_Status       
 *  PTA6                     | -                                           | p6                        | -       
 *  PTA7                     | -                                           | p7                        | -       
 *  PTB0                     | ADC0_SE9                                    | p8                        | TVdd_Sample       
 *  PTB1                     | GPIOB_1                                     | p9                        | TVdd_Enable       
 *  PTB2                     | -                                           | p10                       | -       
 *  PTB3                     | -                                           | p11                       | -       
 *  PTB4                     | GPIOB_4                                     | p12                       | Power_Button       
 *  PTB5                     | TPM1_CH1                                    | p13                       | Clock       
 *  PTA0                     | SWD_CLK                                     | p14                       | SWD_CLK       
 *  PTA1                     | RESET_b                                     | p15                       | RESET_b       
 *  PTA2                     | SWD_DIO                                     | p16                       | SWD_DIO       
 *
 *
 * @section PinsByFunction Pins by Function
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  VSS                      | -                                           | p2                        | -       
 *  PTB0                     | ADC0_SE9                                    | p8                        | TVdd_Sample       
 *  PTA5                     | GPIOA_5/RTC_CLKIN                           | p5                        | TVdd_Status       
 *  PTB1                     | GPIOB_1                                     | p9                        | TVdd_Enable       
 *  PTB4                     | GPIOB_4                                     | p12                       | Power_Button       
 *  PTA4                     | LPUART0_RX                                  | p4                        | Debug_Rx       
 *  PTA3                     | LPUART0_TX                                  | p3                        | Debug_Tx       
 *  PTA1                     | RESET_b                                     | p15                       | RESET_b       
 *  PTA0                     | SWD_CLK                                     | p14                       | SWD_CLK       
 *  PTA2                     | SWD_DIO                                     | p16                       | SWD_DIO       
 *  PTB5                     | TPM1_CH1                                    | p13                       | Clock       
 *
 */

#endif /* PROJECT_HEADERS_PIN_MAPPING_H */

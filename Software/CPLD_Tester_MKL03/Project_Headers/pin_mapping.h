/**
 * @file      pin_mapping.h (generated from MKL03Z4.usbdmHardware)
 * @version   1.3.0
 * @brief     Peripheral declarations for MKL03Z8VFG4
 *
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#ifndef PROJECT_HEADERS_PIN_MAPPING_H
#define PROJECT_HEADERS_PIN_MAPPING_H

#include <stdint.h>
#include <stddef.h>

#include "derivative.h"
#include "pcr.h"
#include "error.h"

/**
 * Namespace enclosing USBDM classes
 */
namespace USBDM {

/**
 * @addtogroup USBDM_Group USBDM Peripheral Interface
 * @brief Hardware Peripheral Interface and library
 * @{
 */
/* Template:_common_settings.xml */

   /**
    * Enables mapping of all allocated pins during startup using mapAllPins() 
    * Not available on this MCU
    */
   static constexpr bool MapAllPinsOnStartup = false;

   /**
    * Controls forcing all pins to be locked in mapAllPins() 
    * Not available on this MCU
    */
   static constexpr uint32_t ForceLockedPins = 0;
   static constexpr uint32_t PinLock_Locked  = 0;

   /**
    * Enables forcing unbonded pins to analogue function in mapAllPins() 
    * Not available on this MCU
    */
   static constexpr bool ForceLockoutUnbondedPins = false;
   
// Use when in-lining makes the release build smaller
#ifdef DEBUG_BUILD
#define INLINE_RELEASE __attribute__((noinline))
#else
#define INLINE_RELEASE __attribute__((always_inline))
#endif

#ifdef DEBUG_BUILD
#define NOINLINE_DEBUG __attribute__((noinline))
#else
#define NOINLINE_DEBUG
#endif

   /* MCGFFCLK - Fixed frequency clock (input to FLL) */
   extern volatile uint32_t SystemMcgffClock;

   /* MCGOUTCLK - Primary output from MCG, various sources */
   extern volatile uint32_t SystemMcgOutClock;

   /* MCGFLLCLK - Output of FLL */
   extern volatile uint32_t SystemMcgFllClock;

   /* MCGPLLCLK - Output of PLL */
   extern volatile uint32_t SystemMcgPllClock;

   /**
    * Calculate a Vector number using an offset from an existing number.
    * This is only useful if related vectors are consecutive e.g. DMA0_IRQn, DMA1_IRQn ...
    *
    * @param vector  Base vector to use
    * @param offset  Offset from base vector
    *
    * @return  Vector number calculated from vector+offset
    */
   constexpr IRQn_Type inline operator+(IRQn_Type vector, unsigned offset) {
      return static_cast<IRQn_Type>(static_cast<unsigned>(vector) + offset);
   }

   /**
    * Calculate a Vector number using an offset from an existing number.
    * This is only useful if related vectors are consecutive e.g. DMA0_IRQn, DMA1_IRQn ...
    *
    * @param vector  Base vector to use
    * @param offset  Offset from base vector
    *
    * @return  Vector number calculated from vector+offset
    */
   constexpr IRQn_Type inline operator+(IRQn_Type vector, int offset) {
      return vector + static_cast<unsigned>(offset);
   }

   /**
    * @tparam  T  Type of comparison object (inferred)
    * @param   a  Left-hand object for comparison
    * @param   b  Right-hand object for comparison
    *
    * @return Smaller of a or b
    */
   template<class T> 
   constexpr T min(const T a, const T b) {
      return (b < a) ? b : a;
   }

   /**
    * @tparam  T  Type of comparison object (inferred)
    * @param   a  Left-hand object for comparison
    * @param   b  Right-hand object for comparison
    *
    * @return Larger of a or b
    */
   template<class T> 
   constexpr T max(const T a, const T b) {
      return (b > a) ? b : a;
   }

   constexpr IRQn_Type IRQn_None = static_cast<IRQn_Type>(-20);

   /** Dummy port information for pins without an associated PCR */
   constexpr PortInfo  __attribute__((unused)) NoPortInfo {0, 0, IRQn_None, 0, NvicPriority_NotInstalled};

   /**
    * Class to static check signal mapping is valid
    * Conditions are chained so only a single assert is reported
    */
   template<class Info, int signalNum> class CheckSignalMapping {
      static constexpr bool check1 = signalNum<Info::numSignals;
      static constexpr bool check2 = !check1 || (Info::info[signalNum].gpioBit != UNMAPPED_PCR);
      static constexpr bool check3 = !check1 || !check2 || (Info::info[signalNum].gpioBit != INVALID_PCR);
      static constexpr bool check4 = !check1 || !check2 || !check3 || (Info::info[signalNum].gpioBit >= 0);
   
      static_assert(check1, "Non-existent signal - Modify Configure.usbdm");
      static_assert(check2, "Signal is not mapped to a pin - Modify Configure.usbdm");
      static_assert(check3, "Signal doesn't exist in this device/package");
      static_assert(check4, "Illegal signal");
   };

   /**
    * Determine the number of elements in an array
    *
    * @tparam T      Deduced array type
    * @tparam N      Deduced array size
    *
    * @return  Size of array in elements
    */
   template<typename T, size_t N>
      consteval size_t sizeofArray(T (&)[N]) {
         return N;
      }

   /**
    * Enter critical section
    *
    * Disables interrupts for a critical section
    *
    * @param cpuSR Variable to hold interrupt state so it can be restored
    *
    * @code
    * uint8_t cpuSR;
    * ...
    * enterCriticalSection(cpuSR);
    *  // Critical section
    * exitCriticalSection(cpuSR);
    * @endcode
    */
   static inline void enterCriticalSection(uint8_t &cpuSR) {
      __asm__ volatile (
            "  MRS   r0, PRIMASK       \n"   // Copy flags
            // It may be possible for a ISR to run here but it
            // would save/restore PRIMASK so this code is OK
            "  CPSID I                 \n"   // Disable interrupts
            "  STRB  r0, %[output]     \n"   // Save flags
            : [output] "=m" (cpuSR) : : "r0");
   }

   /**
    * Exit critical section
    *
    * Restores interrupt state saved by enterCriticalSection()
    *
    * @param cpuSR Variable to holding interrupt state to be restored
    */
   static inline void exitCriticalSection(uint8_t &cpuSR) {
      __asm__ volatile (
            "  LDRB r0, %[input]    \n"  // Retrieve original flags
            "  MSR  PRIMASK,r0;     \n"  // Restore
            : :[input] "m" (cpuSR) : "r0");
   }

   /**
    * Class to implement simple critical sections by disabling interrupts.
    *
    * Disables interrupts for a critical section.
    * This would be from the declaration of the object until the end of
    * enclosing block. An object of this class should be declared at the
    * start of a block. e.g.
    * @code
    *    {
    *       CriticalSection cs;
    *       ...
    *       Protected code
    *       ...
    *    }
    * @endcode
    *
    * @note uses PRIMASK
    */
   class CriticalSection {
   
   private:
      /** Used to record interrupt state on entry */
      volatile uint32_t cpuSR;
   
   public:
      /**
       * Constructor - Enter critical section
       *
       * Disables interrupts for a critical section
       * This would be from the declaration of the object until end of enclosing block.
       */
      CriticalSection() __attribute__((always_inline)) {
         __asm__ volatile (
               "  MRS   r0, PRIMASK       \n"   // Copy flags
               // It may be possible for a ISR to run here but it
               // would save/restore PRIMASK so this code is OK
               "  CPSID I                 \n"   // Disable interrupts
               "  STR  r0, %[output]      \n"   // Save flags
               : [output] "=m" (cpuSR) : : "r0");
      }
   
      /**
       * Destructor - Exit critical section
       *
       * Enables interrupts IFF previously disabled by this object
       * This would be done implicitly by exiting the enclosing block.
       */
      inline ~CriticalSection() __attribute__((always_inline)) {
         __asm__ volatile (
               "  LDR r0, %[input]     \n"  // Retrieve original flags
               "  MSR  PRIMASK,r0;     \n"  // Restore
               : :[input] "m" (cpuSR) : "r0");
      }
   };
/* END Template:_common_settings.xml */

/*
 * Peripheral Information Classes
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Abstraction for Digital Input/Output
 * @{
 */
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
/* gpio_def.xml */

#if defined(PCC_PCC_PORTA_CGC_MASK)
   /** Port information for PORTA */
   constexpr PortInfo  __attribute__((unused)) PortAInfo {PORTA_BasePtr, static_cast<uint32_t>(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTA)), PORTA_IRQn, GPIOA_BasePtr, NvicPriority_Normal};
#elif defined(SIM_SCGC5_PORTA_MASK)
#ifndef PORTA_IRQS
   /** Port information for PORTA */
   constexpr PortInfo  __attribute__((unused)) PortAInfo {PORTA_BasePtr, SIM_SCGC5_PORTA_MASK, IRQn_None, GPIOA_BasePtr, NvicPriority_Normal};
#else
   constexpr IRQn_Type PORTA_IRQS_AR[] = PORTA_IRQS;
   /** Port information for PORTA */
   constexpr PortInfo  __attribute__((unused)) PortAInfo {PORTA_BasePtr, SIM_SCGC5_PORTA_MASK, PORTA_IRQS_AR[0], GPIOA_BasePtr, NvicPriority_Normal};
#endif
#endif

class GpioAInfo {
public:
   /*
    * Template:fgpioa_0xf8000000
    */
   //! Number of signals available in info table
   static constexpr int numSignals  = 13;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: GPIOA_0              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: GPIOA_1              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: GPIOA_2              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: GPIOA_3              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: GPIOA_4              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   5: GPIOA_5              = PTA5(p5)                       */  { PortAInfo,  5,            (PcrValue)0x00100UL  },
         /*   6: GPIOA_6              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   7: GPIOA_7              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   8: GPIOA_8              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   9: GPIOA_9              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  10: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  11: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  12: GPIOA_12             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCLR = 0x0100UL|PORT_GPCLR_GPWE(0x0020UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0020UL);
   }

};

/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
/* gpio_def.xml */

#if defined(PCC_PCC_PORTB_CGC_MASK)
   /** Port information for PORTB */
   constexpr PortInfo  __attribute__((unused)) PortBInfo {PORTB_BasePtr, static_cast<uint32_t>(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTB)), PORTB_IRQn, GPIOB_BasePtr, NvicPriority_Normal};
#elif defined(SIM_SCGC5_PORTB_MASK)
#ifndef PORTB_IRQS
   /** Port information for PORTB */
   constexpr PortInfo  __attribute__((unused)) PortBInfo {PORTB_BasePtr, SIM_SCGC5_PORTB_MASK, IRQn_None, GPIOB_BasePtr, NvicPriority_Normal};
#else
   constexpr IRQn_Type PORTB_IRQS_AR[] = PORTB_IRQS;
   /** Port information for PORTB */
   constexpr PortInfo  __attribute__((unused)) PortBInfo {PORTB_BasePtr, SIM_SCGC5_PORTB_MASK, PORTB_IRQS_AR[0], GPIOB_BasePtr, NvicPriority_Normal};
#endif
#endif

class GpioBInfo {
public:
   /*
    * Template:fgpioa_0xf8000000
    */
   //! Number of signals available in info table
   static constexpr int numSignals  = 14;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: GPIOB_0              = PTB0(p8)                       */  { PortBInfo,  0,            (PcrValue)0x00100UL  },
         /*   1: GPIOB_1              = PTB1(p9)                       */  { PortBInfo,  1,            (PcrValue)0x00100UL  },
         /*   2: GPIOB_2              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: GPIOB_3              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: GPIOB_4              = PTB4(p12)                      */  { PortBInfo,  4,            (PcrValue)0x00100UL  },
         /*   5: GPIOB_5              = PTB5(p13)                      */  { PortBInfo,  5,            (PcrValue)0x00100UL  },
         /*   6: GPIOB_6              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   7: GPIOB_7              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   8: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   9: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  10: GPIOB_10             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  11: GPIOB_11             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  12: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  13: GPIOB_13             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTB_CLOCK_MASK);
#endif

   PORTB->GPCLR = 0x0100UL|PORT_GPCLR_GPWE(0x0033UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTB_CLOCK_MASK);
#endif

   PORTB->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0033UL);
   }

};

/** 
 * End group GPIO_Group
 * @}
 */
/**
 * @addtogroup PMC_Group PMC, Power Management Controller
 * @brief Abstraction for Power Management Controller
 * @{
 */
/**
 * Peripheral information for PMC, Power Management Controller.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Low-Voltage Detect action select
    *
    * Selects the action to take on low voltage detect
    * Note that Reset action is a write-once selection
    */
   enum PmcLowVoltageDetectAction : uint8_t {
      PmcLowVoltageDetectAction_None      = (PMC_LVDSC1_LVDRE(0)|PMC_LVDSC1_LVDIE(0)), ///< No Action
      PmcLowVoltageDetectAction_Interrupt = (PMC_LVDSC1_LVDRE(0)|PMC_LVDSC1_LVDIE(1)), ///< Interrupt
      PmcLowVoltageDetectAction_Reset     = (PMC_LVDSC1_LVDRE(1)|PMC_LVDSC1_LVDIE(0)), ///< Reset

   };

   /**
    * Low-Voltage Detect voltage select
    *
    * Selects the LVD trip point voltage (Vlvd)
    */
   enum PmcLowVoltageDetectLevel : uint8_t {
      PmcLowVoltageDetectLevel_Low  = PMC_LVDSC1_LVDV(0), ///< Low trip point selected
      PmcLowVoltageDetectLevel_High = PMC_LVDSC1_LVDV(1), ///< High trip point selected

   };

   /**
    * Low-Voltage Warning Interrupt Enable
    *
    * Action to take on Low Voltage Warning
    */
   enum PmcLowVoltageWarningAction : uint8_t {
      PmcLowVoltageWarningAction_None      = PMC_LVDSC2_LVWIE(0), ///< No action
      PmcLowVoltageWarningAction_Interrupt = PMC_LVDSC2_LVWIE(1), ///< Interrupt

   };

   /**
    * Low-Voltage Warning Voltage Select
    *
    * Selects the LVW trip point voltage (Vlvw)
    * The actual voltage for the warning depends on pmc_lvdsc1_lvdv
    */
   enum PmcLowVoltageWarningLevel : uint8_t {
      PmcLowVoltageWarningLevel_Low     = PMC_LVDSC2_LVWV(0), ///< Low trip point selected
      PmcLowVoltageWarningLevel_MidLow  = PMC_LVDSC2_LVWV(1), ///< Mid 1 trip point selected
      PmcLowVoltageWarningLevel_MidHigh = PMC_LVDSC2_LVWV(2), ///< Mid 2 trip point selected
      PmcLowVoltageWarningLevel_High    = PMC_LVDSC2_LVWV(3), ///< High trip point selected

   };

   /**
    * Bandgap Enable In VLPx Operation
    *
    * BGEN controls whether the bandgap is enabled in 
    * lower power modes of operation (VLPx, LLS, and VLLSx)
    */
   enum PmcBandgapOperationInLowPower : uint8_t {
      PmcBandgapOperationInLowPower_Disabled = PMC_REGSC_BGEN(0), ///< Disabled
      PmcBandgapOperationInLowPower_Enabled  = PMC_REGSC_BGEN(1), ///< Enabled

   };

   /**
    * Bandgap Buffer Enable
    *
    * Controls whether the band-gap reference is available to internal devices e.g. CMP etc
    */
   enum PmcBandgapBuffer : uint8_t {
      PmcBandgapBuffer_Disabled = PMC_REGSC_BGBE(0), ///< Disabled
      PmcBandgapBuffer_Enabled  = PMC_REGSC_BGBE(1), ///< Enabled

   };

class PmcInfo {
public:
   /*
    * Template:pmc_mk
    */
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = PMC_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<PMC_Type> pmc = baseAddress;

   //! Frequency of Low Power Oscillator (LPO) Clock [~1kHz]
   static constexpr uint32_t system_low_power_clock = 1000UL;

   /**
    * Get LPO clock
    *
    * @return frequency in Hz as uint32_t
    */
   static constexpr uint32_t getLpoClock() {
      return system_low_power_clock;
   }

   //! Default value for Low Voltage Detect Status And Control 1 register
   static constexpr uint32_t pmc_lvdsc1  = 
      PmcLowVoltageDetectAction_None | // Low-Voltage Detect action select 
      PmcLowVoltageDetectLevel_Low | // Low-Voltage Detect voltage select 
      0;

   //! Default value for Low Voltage Detect Status And Control 2 register
   static constexpr uint32_t pmc_lvdsc2  = 
      PmcLowVoltageWarningAction_None | // Low-Voltage Warning Interrupt Enable 
      PmcLowVoltageWarningLevel_Low | // Low-Voltage Warning Voltage Select 
      0;

   //! Default value for Regulator Status And Control register
   static constexpr uint32_t pmc_regsc  = 
      PmcBandgapOperationInLowPower_Disabled | // Bandgap Enable In VLPx Operation 
      PmcBandgapBuffer_Disabled | // Bandgap Buffer Enable 
      0;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = PMC_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_Normal;

};

/** 
 * End group PMC_Group
 * @}
 */
/**
 * @addtogroup OSC_Group OSC, Crystal Oscillator
 * @brief Abstraction for Crystal Oscillator
 * @{
 */
/**
 * Peripheral information for OSC, Crystal Oscillator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * External Reference Enable
    *
    * Enables the OSC clock [OSCERCLK] for use by peripherals
    * The oscillator will also be enabled if used by MCG
    */
   enum OscErClkEn {
      OscErClkEn_Disabled = OSC_CR_ERCLKEN(0), ///< Disabled
      OscErClkEn_Enabled  = OSC_CR_ERCLKEN(1), ///< Enabled

   };

class Osc0Info {
public:
   /*
    * Template:osc0_mk
    */
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = OSC0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<OSC_Type> osc = baseAddress;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Frequency of OSC Clock or Crystal
   static constexpr uint32_t osc_clock = 0UL;

   //! Frequency of 32K OSC Clock or Crystal (if applicable)
   static constexpr uint32_t osc32k_clock = 0UL;

   //! Oscillator control register
   static constexpr uint32_t cr =
      OSC_CR_ERCLKEN(0)  | // External Reference Enable
      OSC_CR_EREFSTEN(0) | // External Reference Stop Enable
      OSC_CR_SCP(2);       // Oscillator load capacitance

   /**
    * Get OSC clock (internal, assumed available)
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static constexpr uint32_t getOscClock() {
      return osc_clock;
   }

   /**
    * Get OSC clock (external, gated by OSC_CR_ERCLKEN)
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static uint32_t getOscerClock() {
      return (osc->CR&OSC_CR_ERCLKEN_MASK)?osc_clock:0;
   }

   /**
    * Get OSC32KCLK clock
    *
    * @return Clock frequency as uint32_t in Hz
   
    * @note This clock is only available if a 32kHz crystal or external clock is used
    */
   static uint32_t getOsc32kClock() {
      return osc32k_clock;
   }

   /**
    * External Reference Enable
    *
    * @param oscErClkEn  Enables the OSC clock [OSCERCLK] for use by peripherals
    *        The oscillator will also be enabled if used by MCG
    */
   static void enableExternalReference(OscErClkEn oscErClkEn) {
      osc->CR = (osc->CR&~OSC_CR_ERCLKEN_MASK) | oscErClkEn;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: XTAL0                = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: EXTAL0               = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group OSC_Group
 * @}
 */
/**
 * @addtogroup RTC_Group RTC, Real Time Clock
 * @brief Abstraction for Real Time Clock
 * @{
 */
/**
 * Peripheral information for RTC, Real Time Clock.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class RtcInfo {
public:
   /*
    * Template:rtc_wps_mkl03z4
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = RTC_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<RTC_Type> rtc = baseAddress;

   //! Whether to configure RTC
   //! If disabled then no RTC registers are accessed.
   //! This is useful if RTC is not powered as register access will trap.
   static constexpr bool EnableRtc = 0;
   
   //! Oscillator control register
   static constexpr uint32_t cr = 
      RTC_CR_OSCE(0) | // Enable RTC oscillator - Disabled
      RTC_CR_UM(0) | // Update Mode - SR[TCE] cannot be written when locked
      RTC_CR_SUP(0) | // Supervisor access - Non-supervisor write accesses not supported
      RTC_CR_WPE(0) | // Wakeup Pin Enable - Wakeup pin is disabled
      RTC_CR_SCP(2);  // Oscillator load capacitance - 8 pF
   
   //! RTC Time Compensation Register
   static constexpr uint32_t tcr = 
      RTC_TCR_CIR(0) | // Compensation Interval Register
      RTC_TCR_TCR(0);  // Time Compensation Register
   
   //! RTC Lock Register
   static constexpr uint32_t lr = 
      RTC_LR_LRL(1) | // Lock Register Lock - Unlocked
      RTC_LR_SRL(1) | // Status Register Lock - Unlocked
      RTC_LR_CRL(1) | // Control Register Lock - Unlocked
      RTC_LR_TCL(1);  // Time Compensation Lock - Unlocked
   
   /* Template_irqOptionSubstituted.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = RTC_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   //! Time for cold start (corrected for time zone)
   static constexpr uint32_t coldStartTime =
          1672538401 + 10*60*60;
   
   /** 
    *  Enable clock to Rtc
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableRtcClock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_RTC_MASK;
#endif
   }

   /** 
    *  Disable clock to Rtc
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableRtcClock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_RTC_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: XTAL32               = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: EXTAL32              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: RTC_CLKOUT           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: RTC_CLKIN            = PTA5(p5)                       */  { PortAInfo,  5,            (PcrValue)0x00100UL  },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCLR = 0x0100UL|PORT_GPCLR_GPWE(0x0020UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0020UL);
   }

};

/** 
 * End group RTC_Group
 * @}
 */
/**
 * @addtogroup MCG_Group MCG, Multipurpose Clock Generator
 * @brief Abstraction for Multipurpose Clock Generator
 * @{
 */
/**
 * Peripheral information for MCG, Multipurpose Clock Generator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * OSC0 source control
    *
    * Determines whether an external clock or crystal is used
    * and oscillator mode for OSC0
    */
   enum OscMode {
      OscMode_ExternalClock      = MCG_C2_EREFS0(0), ///< External clock
      OscMode_LowPowerOscillator = MCG_C2_EREFS0(1), ///< Low Power Oscillator

   };

   /**
    * MCG Clock Mode
    *
    * Clock Modes
    * LIRC_8MHz  -  8 MHz low power internal reference clock
    * LIRC_2MHz  -  2 MHz low power internal reference clock
    * HIRC_48MHz -  48 MHz high speed internal reference clock
    * EXT        -  External reference clock (OSCCLK)
    */
   enum McgClockMode {
      McgClockMode_LIRC_2MHz  = 0, ///< 2 MHz low power IRC (LIRC_2MHz)
      McgClockMode_LIRC_8MHz  = 1, ///< 8 MHz low power IRC (LIRC_8MHz)
      McgClockMode_HIRC_48MHz = 2, ///< 48 MHz IRC (HIRC_48MHz)
      McgClockMode_EXT        = 3, ///< External (EXT)

   };

class McgInfo {
public:
   /*
    * Template:mcg_lite_32k
    */
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = MCG_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<MCG_Type> mcg = baseAddress;

   //! Frequency of Slow Internal Reference Clock [~2MHz]
   static constexpr uint32_t system_slow_lirc_clock = 2000000UL;

   //! Frequency of Fast Internal Reference Clock [~8MHz]
   static constexpr uint32_t system_fast_lirc_clock = 8000000UL;

   //! Frequency of HIRC [~48MHz]
   static constexpr uint32_t system_irc48m_clock = 48000000UL;

   /**
    * Get HIRC_CLK
    *
    * @return frequency in Hz as uint32_t
    */
   static uint32_t getMcgPClk() {
      // Directly enabled or required by current MCG clock mode
      if ((mcg->MC&MCG_MC_HIRCEN_MASK) || ((mcg->S&MCG_S_CLKST_MASK) == MCG_S_CLKST(0))) {
         return system_irc48m_clock;
      }
      else {
         return 0;
      }
   }

   /**
    * Get LIRC_CLK
    *
    * @return frequency in Hz as uint32_t
    */
   static uint32_t getLircClk() {
      if ((mcg->C1&MCG_C1_IRCLKEN_MASK) || ((mcg->S&MCG_S_CLKST_MASK) == MCG_S_CLKST(1))) {
         if (mcg->C2&MCG_C2_IRCS_MASK) {
            return system_fast_lirc_clock;
         }
         else {
            return system_slow_lirc_clock;
         }
      }
      else {
         return 0;
      }
   }

   /**
    * Get LIRC_DIV1_CLK
    *
    * @return frequency in Hz as uint32_t
    */
   static uint32_t getLircDiv1Clk() {
      return getLircClk()/(1<<((mcg->SC&MCG_SC_FCRDIV_MASK)>>MCG_SC_FCRDIV_SHIFT));
   }
   
   /**
    * Get MCGIRCLK
    *
    * @return frequency in Hz as uint32_t
    */
   static uint32_t getMcgIrClock() {
      return getLircDiv1Clk()/(1<<((mcg->MC&MCG_MC_LIRC_DIV2_MASK)>>MCG_MC_LIRC_DIV2_SHIFT));
   }

   /**
    * Get MCGOUTCLK
    *
    * @return frequency in Hz as uint32_t
    */
   static uint32_t getMcgOutClock() {
      switch (mcg->S&MCG_S_CLKST_MASK) {
      case MCG_S_CLKST(0): // HIRC
         return getMcgPClk();
      case MCG_S_CLKST(1): // LIRC (IRC2Mz/IRC8Mz)/DIV1
         return getLircDiv1Clk();
      case MCG_S_CLKST(2): // External clock (OSC0)
         return Osc0Info::getOscClock();
      default:
      case MCG_S_CLKST(3): // Reserved
         return 0;
      }
   }

};

/** 
 * End group MCG_Group
 * @}
 */
/**
 * @addtogroup SIM_Group SIM, System Integration Module
 * @brief Abstraction for System Integration Module
 * @{
 */
/**
 * Peripheral information for SIM, System Integration Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * COP Watchdog Timeout
    *
    * Selects the Computer Operating Properly Timeout
    * This is a write-once field
    */
   enum SimCopDuration {
      SimCopDuration_Disabled      = SIM_COPC_COPCLKS(0)|SIM_COPC_COPT(0), ///< Disabled
      SimCopDuration_32_cycles     = SIM_COPC_COPCLKS(0)|SIM_COPC_COPT(1), ///< Timeout after 2^5 clock cycles
      SimCopDuration_256_cycles    = SIM_COPC_COPCLKS(0)|SIM_COPC_COPT(2), ///< Timeout after 2^8 clock cycles
      SimCopDuration_1024_cycles   = SIM_COPC_COPCLKS(0)|SIM_COPC_COPT(3), ///< Timeout after 2^10 clock cycles
      SimCopDuration_8192_cycles   = SIM_COPC_COPCLKS(1)|SIM_COPC_COPT(1), ///< Timeout after 2^13 clock cycles
      SimCopDuration_65536_cycles  = SIM_COPC_COPCLKS(1)|SIM_COPC_COPT(2), ///< Timeout after 2^16 clock cycles
      SimCopDuration_262144_cycles = SIM_COPC_COPCLKS(1)|SIM_COPC_COPT(3), ///< Timeout after 2^18 clock cycles

   };

   /**
    * COP Clock Select
    *
    * Selects the clock source of the COP watchdog
    * This is a write-once field
    */
   enum SimCopClkSrc {
      SimCopClkSrc_LpoClk   = SIM_COPC_COPCLKSEL(0), ///< LPO clock (1 kHz)
      SimCopClkSrc_McgirClk = SIM_COPC_COPCLKSEL(1), ///< MCGIRCLK
      SimCopClkSrc_OscerClk = SIM_COPC_COPCLKSEL(2), ///< OSCERCLK
      SimCopClkSrc_BusClk   = SIM_COPC_COPCLKSEL(3), ///< Bus clock

   };

   /**
    * COP Debug Enable
    *
    * Controls whether COP is enabled in debug mode
    * This is a write-once field
    */
   enum SimCopDebugMode {
      SimCopDebugMode_HeldReset = SIM_COPC_COPDBGEN(0), ///< COP is disabled and the counter is reset
      SimCopDebugMode_Enabled   = SIM_COPC_COPDBGEN(1), ///< COP is enabled

   };

   /**
    * COP Stop Enable
    *
    * Controls whether COP is enabled in stop mode
    * This is a write-once field
    */
   enum SimCopStopMode {
      SimCopStopMode_HeldReset = SIM_COPC_COPSTPEN(0), ///< COP is disabled and the counter is reset
      SimCopStopMode_Enabled   = SIM_COPC_COPSTPEN(1), ///< COP is enabled

   };

   /**
    * COP Windowed Mode
    *
    * Windowed mode is only supported when COP is using longer periods
    * The COP window is opened three quarters through the timeout period
    * This is a write-once field
    */
   enum SimCopMode {
      SimCopMode_Normal     = SIM_COPC_COPW(0), ///< Normal Mode
      SimCopMode_WindowMode = SIM_COPC_COPW(1), ///< Windowed Mode

   };

   /**
    * ERCLK32K Clock Output
    *
    * Outputs the ERCLK32K on the selected pin in all modes of operation
    */
   enum SimErc32kClkoutPinSelect {
      SimErc32kClkoutPinSelect_None  = SIM_SOPT1_OSC32KOUT(0), ///< ERCLK32K is not output
      SimErc32kClkoutPinSelect_PTB13 = SIM_SOPT1_OSC32KOUT(1), ///< ERCLK32K is output on PTB13

   };

   /**
    * TPM 0 External Clock Pin
    *
    * External pin used to drive the clock to the TPM module
    */
   enum SimTpm0ClkSel {
      SimTpm0ClkSel_0 = SIM_SOPT4_TPM0CLKSEL(0), ///< TPM_CLKIN0 pin
      SimTpm0ClkSel_1 = SIM_SOPT4_TPM0CLKSEL(1), ///< TPM_CLKIN1 pin

   };

   /**
    * TPM 1 External Clock Pin
    *
    * External pin used to drive the clock to the TPM module
    */
   enum SimTpm1ClkSel {
      SimTpm1ClkSel_0 = SIM_SOPT4_TPM1CLKSEL(0), ///< TPM_CLKIN0 pin
      SimTpm1ClkSel_1 = SIM_SOPT4_TPM1CLKSEL(1), ///< TPM_CLKIN1 pin

   };

   /**
    * TPM 1 channel 0 input capture source
    *
    * Source for TPM channel input capture
    * NOTE: When the TPM is not in input capture mode, clear this field
    */
   enum SimTpm1Ch0Src {
      SimTpm1Ch0Src_IcPin = SIM_SOPT4_TPM1CH0SRC(0), ///< TPM CH0 signal
      SimTpm1Ch0Src_Cmp0  = SIM_SOPT4_TPM1CH0SRC(1), ///< CMP0 output

   };

   /**
    * LPUART0 Open Drain
    *
    * Enables Open Drain output
    */
   enum SimLpuart0Drive {
      SimLpuart0Drive_PushPull  = SIM_SOPT5_LPUART0ODE(0), ///< Push-pull
      SimLpuart0Drive_OpenDrain = SIM_SOPT5_LPUART0ODE(1), ///< Open-drain

   };

   /**
    * LPUART0 receive data source
    *
    * Source for the LPUART0 receive data
    */
   enum SimLpuart0RxSrc {
      SimLpuart0RxSrc_RxPin = SIM_SOPT5_LPUART0RXSRC(0), ///< Rx pin
      SimLpuart0RxSrc_Cmp0  = SIM_SOPT5_LPUART0RXSRC(1), ///< CMP0 output

   };

   /**
    * LPUART0 transmit data source
    *
    * Source for the LPUART0 transmit data
    */
   enum SimLpuart0TxSrc {
      SimLpuart0TxSrc_Direct             = SIM_SOPT5_LPUART0TXSRC(0), ///< Tx pin
      SimLpuart0TxSrc_ModulatedByTpm1Ch0 = SIM_SOPT5_LPUART0TXSRC(1), ///< Tx pin modulated by TPM1 channel 0

   };

   /**
    * ADC0 trigger mode
    *
    * Alternative conversion triggers for ADC
    * _Tpm              - ADC is triggered by TPM. Pre-triggers are TPM channel 0 (A) and channel 1 (B)
    * _Alt_PreTrigger_0 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
    * _Alt_PreTrigger_1 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
    */
   enum SimAdc0TriggerMode {
      SimAdc0TriggerMode_Tpm              = SIM_SOPT7_ADC0ALTTRGEN(0)|SIM_SOPT7_ADC0PRETRGSEL(0), ///< Triggered by TPM Ch0 and Ch1
      SimAdc0TriggerMode_Alt_PreTrigger_0 = SIM_SOPT7_ADC0ALTTRGEN(1)|SIM_SOPT7_ADC0PRETRGSEL(0), ///< Pre-trigger 0 = A (SC1[0])
      SimAdc0TriggerMode_Alt_PreTrigger_1 = SIM_SOPT7_ADC0ALTTRGEN(1)|SIM_SOPT7_ADC0PRETRGSEL(1), ///< Pre-trigger 1 = B (SC1[1])

   };

   /**
    * ADC0 trigger source
    *
    * ADC Trigger source in STOP and VLPS modes, or when ADC Alternative Trigger is active
    */
   enum SimAdc0TriggerSrc {
      SimAdc0TriggerSrc_External   = SIM_SOPT7_ADC0TRGSEL(0),  ///< External trigger pin input (EXTRG_IN)
      SimAdc0TriggerSrc_Cmp0       = SIM_SOPT7_ADC0TRGSEL(1),  ///< CMP 0 output
      SimAdc0TriggerSrc_Tpm0       = SIM_SOPT7_ADC0TRGSEL(8),  ///< TPM0 trigger
      SimAdc0TriggerSrc_Tpm1       = SIM_SOPT7_ADC0TRGSEL(9),  ///< TPM1 trigger
      SimAdc0TriggerSrc_RtcAlarm   = SIM_SOPT7_ADC0TRGSEL(12), ///< RTC alarm
      SimAdc0TriggerSrc_RtcSeconds = SIM_SOPT7_ADC0TRGSEL(13), ///< RTC seconds
      SimAdc0TriggerSrc_Lptmr      = SIM_SOPT7_ADC0TRGSEL(14), ///< LPTMR trigger

   };

   /**
    * CLKOUT pin clock
    *
    * Clock to output on the CLKOUT pin
    */
   enum SimClkoutSel {
      SimClkoutSel_Unused0   = SIM_SOPT2_CLKOUTSEL(0), ///< Disabled0
      SimClkoutSel_Unused1   = SIM_SOPT2_CLKOUTSEL(1), ///< Disabled1
      SimClkoutSel_BusClk    = SIM_SOPT2_CLKOUTSEL(2), ///< Bus clock
      SimClkoutSel_LpoClk    = SIM_SOPT2_CLKOUTSEL(3), ///< LPO clock (1 kHz)
      SimClkoutSel_McgLirClk = SIM_SOPT2_CLKOUTSEL(4), ///< LIRC_CLK (8/2 MHz)
      SimClkoutSel_Unused5   = SIM_SOPT2_CLKOUTSEL(5), ///< Disabled5
      SimClkoutSel_OscerClk0 = SIM_SOPT2_CLKOUTSEL(6), ///< OSCERCLK0
      SimClkoutSel_Irc48MClk = SIM_SOPT2_CLKOUTSEL(7), ///< IRC 48 MHz clock

   };

   /**
    * LPUART0 Clock
    *
    * Clock source for the transmit and receive clock
    */
   enum SimLpuart0ClockSource {
      SimLpuart0ClockSource_Disabled      = SIM_SOPT2_LPUART0SRC(0), ///< Disabled
      SimLpuart0ClockSource_PeripheralClk = SIM_SOPT2_LPUART0SRC(1), ///< Peripheral Clock (MCGPCLK)
      SimLpuart0ClockSource_OscerClk      = SIM_SOPT2_LPUART0SRC(2), ///< OSCERCLK clock
      SimLpuart0ClockSource_McgIrClk      = SIM_SOPT2_LPUART0SRC(3), ///< MCGIRCLK clock

   };

   /**
    * TPM Clock source
    *
    * Clock source for the TPM counter clock
    */
   enum SimTpmClockSource {
      SimTpmClockSource_Disabled      = SIM_SOPT2_TPMSRC(0), ///< Disabled
      SimTpmClockSource_PeripheralClk = SIM_SOPT2_TPMSRC(1), ///< Peripheral Clock (MCGPCLK)
      SimTpmClockSource_OscerClk      = SIM_SOPT2_TPMSRC(2), ///< OSCERCLK clock
      SimTpmClockSource_McgIrClk      = SIM_SOPT2_TPMSRC(3), ///< MCGIRCLK clock

   };

   /**
    * ERCLK32K clock source
    *
    * Clock source for External 32k Reference Clock [ERCLK32K]
    */
   enum SimErc32kSel {
      SimErc32kSel_Osc32kClk = SIM_SOPT1_OSC32KSEL(0), ///< OSC32KCLK
      SimErc32kSel_RtcClkin  = SIM_SOPT1_OSC32KSEL(2), ///< RTC_CLKIN pin
      SimErc32kSel_LpoClk    = SIM_SOPT1_OSC32KSEL(3), ///< LPO 1kHz clock

   };

   /**
    * RTC clock out source
    *
    * Clock output on the RTC_CLKOUT pin
    */
   enum SimRtcClkoutSel {
      SimRtcClkoutSel_1Hz   = SIM_SOPT2_RTCCLKOUTSEL(0), ///< RTC 1 Hz clock
      SimRtcClkoutSel_32kHz = SIM_SOPT2_RTCCLKOUTSEL(1), ///< OSCERCLK

   };

class SimInfo {
public:
   /*
    * Template:sim_mkl03z4
    */
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = SIM_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<SIM_Type> sim = baseAddress;

   /**
    * Get Peripheral clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    *
    * @note If there is a peripheral clock divider then this is the
    *       frequency of the undivided peripheral clock
    */
   static uint32_t getPeripheralClock() {
   
      return McgInfo::getMcgPClk();
   }

   /**
    * Update system clock values
    *
    * @param systemClock Frequency of clock provided to system clock dividers
    */
   static void updateSystemClocks(unsigned systemClock) {
   
      SystemCoreClock    = systemClock/(((SIM->CLKDIV1&SIM_CLKDIV1_OUTDIV1_MASK)>>SIM_CLKDIV1_OUTDIV1_SHIFT)+1);
      SystemBusClock     = SystemCoreClock/(((SIM->CLKDIV1&SIM_CLKDIV1_OUTDIV4_MASK)>>SIM_CLKDIV1_OUTDIV4_SHIFT)+1);
   }

   /*
    * Template:sim_commonTemplates.xml
    */ 
   /**
    * Set RTC clock out source
    *
    * @param simRtcClkoutSel Clock output on the RTC_CLKOUT pin
    */
   static void setRtcClockout(SimRtcClkoutSel simRtcClkoutSel) {
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_RTCCLKOUTSEL_MASK) | simRtcClkoutSel;
   }

   /// Frequency of Internal 48MHz Clock [IRC48MCLK]
   static constexpr uint32_t irc48mClock=48000000;

   /// Frequency of clock provided to RTC external input pin
   static constexpr uint32_t rtc_clkin_clock = 0;  

   /**
    * Set ERCLK32K clock source
    *
    * @param simErc32kSel Clock source for External 32k Reference Clock [ERCLK32K]
    */
   static void setErc32kClock(SimErc32kSel simErc32kSel) {
      sim->SOPT1 = (sim->SOPT1&~SIM_SOPT1_OSC32KSEL_MASK) | simErc32kSel;
   }

   /**
    * Get ERCLK32K clock source
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getErc32kClock() {
   
      switch(sim->SOPT1&SIM_SOPT1_OSC32KSEL_MASK) {
         default: return 0;
         case SimErc32kSel_Osc32kClk : return Osc0Info::getOscerClock(); ///< OSC32KCLK
         case SimErc32kSel_RtcClkin  : return rtc_clkin_clock;           ///< RTC_CLKIN pin
         case SimErc32kSel_LpoClk    : return PmcInfo::getLpoClock();    ///< LPO 1kHz clock

      }
   }

   /**
    * Set ERCLK32K Clock Output
    *
    * @param simErc32kClkoutPinSelect Outputs the ERCLK32K on the selected pin in all modes of operation
    */
   static void setErc32kClkoutPin(SimErc32kClkoutPinSelect simErc32kClkoutPinSelect) {
      sim->SOPT1 = (sim->SOPT1&~SIM_SOPT1_OSC32KOUT_MASK) | simErc32kClkoutPinSelect;
   }

   /**
    * Set CLKOUT pin clock
    *
    * @param simClkoutSel Clock to output on the CLKOUT pin
    */
   static void setClkout(SimClkoutSel simClkoutSel) {
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_CLKOUTSEL_MASK) | simClkoutSel;
   }
   
   /**
    * Get CLKOUT pin clock
    *
    * @return Clock to output on the CLKOUT pin
    */
   static uint32_t getClkout() {
   
      return sim->SOPT2&SIM_SOPT2_CLKOUTSEL_MASK;
   }

   /**
    * Set TPM Clock source
    *
    * @param simTpmClockSource Clock source for the TPM counter clock
    */
   static void setTpmClock(SimTpmClockSource simTpmClockSource) {
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_TPMSRC_MASK) | simTpmClockSource;
   }

   /**
    * Get TPM Clock source
    *  Clock source for the TPM counter clock
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getTpmClock() {
   
      switch(sim->SOPT2&SIM_SOPT2_TPMSRC_MASK) {
         default: return 0;
         case SimTpmClockSource_Disabled      : return 0;                         ///< Disabled
         case SimTpmClockSource_PeripheralClk : return getPeripheralClock();      ///< Peripheral Clock (MCGPCLK)
         case SimTpmClockSource_OscerClk      : return Osc0Info::getOscerClock(); ///< OSCERCLK clock
         case SimTpmClockSource_McgIrClk      : return McgInfo::getMcgIrClock();  ///< MCGIRCLK clock

      }
   }

   /**
    * Set LPUART0 Clock
    *
    * @param simLpuart0ClockSource Clock source for the transmit and receive clock
    */
   static void setLpuart0Clock(SimLpuart0ClockSource simLpuart0ClockSource) {
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_LPUART0SRC_MASK) | simLpuart0ClockSource;
   }

   /**
    * Get LPUART0 Clock
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getLpuart0Clock() {
   
      switch(sim->SOPT2&SIM_SOPT2_LPUART0SRC_MASK) {
         default: return 0;
         case SimLpuart0ClockSource_Disabled      : return 0;                         ///< Disabled
         case SimLpuart0ClockSource_PeripheralClk : return getPeripheralClock();      ///< Peripheral Clock (MCGPCLK)
         case SimLpuart0ClockSource_OscerClk      : return Osc0Info::getOscerClock(); ///< OSCERCLK clock
         case SimLpuart0ClockSource_McgIrClk      : return McgInfo::getMcgIrClock();  ///< MCGIRCLK clock

      }
   }

   /**
    * Class used to do initialisation of SIM Clock control (SOPT2)
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Generic Example: (see Sim::DefaultSopt2Values for device specific example)
    * @code
    * static const ClockInit clockInit {
    *    SimUsbFullSpeedClockSource_McgPClk, // USB Clock - Peripheral clock (MCGPCLK)
    *    SimTpmClockSource_McgPClk,          // TPM Clock source - MCGPCLK (HIRC=IRC48M) Clock
    *    SimFlexioClockSource_McgPClk,       // FLEXIO Clock select - MCGPCLK (HIRC=IRC48M) Clock
    *    SimClkoutSel_LpoClk,                // CLKOUT pin clock - LPO clock (1 kHz)
    *    SimRtcClkoutSel_32kHz,              // RTC clock out source - OSC32KCLK clock (from OSC0)
    *    SimLpuart0ClockSource_McgPClk,      // LPUART0 Clock - MCGPCLK (HIRC=IRC48M) Clock
    *    SimLpuart1ClockSource_McgPClk,      // LPUART1 Clock - MCGPCLK (HIRC=IRC48M) Clock
    *
    *    // Base value modified by above
    *    Sim::DefaultSopt2Values[McgClockMode_HIRC_48MHz]
    * };
    *
    * // Initialise SIM Clock control from values specified above
    * clockInit.configure()
    * @endcode
    */
   class ClockInit {
   
   public:
   
      /// System Options Register 2
      uint32_t sopt2 = 0;
   
      /**
       * Copy Constructor
       */
      constexpr ClockInit(const ClockInit &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr ClockInit() = default;
   
      /**
       * Configure SIM Clock control from values specified in constructor.
       */
      void configure() const {

         sim->SOPT2 = sopt2;
      }

      /**
       * Constructor for TPM Clock source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simTpmClockSource Clock source for the TPM counter clock
       */
      template <typename... Types>
      constexpr ClockInit(SimTpmClockSource simTpmClockSource, Types... rest) : ClockInit(rest...) {
   
         sopt2 |= simTpmClockSource;
      }
   
      /**
       * Constructor for CLKOUT pin clock
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simClkoutSel Clock to output on the CLKOUT pin
       */
      template <typename... Types>
      constexpr ClockInit(SimClkoutSel simClkoutSel, Types... rest) : ClockInit(rest...) {
   
         sopt2 |= simClkoutSel;
      }
   
      /**
       * Constructor for RTC clock out source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simRtcClkoutSel Clock output on the RTC_CLKOUT pin
       */
      template <typename... Types>
      constexpr ClockInit(SimRtcClkoutSel simRtcClkoutSel, Types... rest) : ClockInit(rest...) {
   
         sopt2 |= simRtcClkoutSel;
      }
   
      /**
       * Constructor for LPUART0 Clock
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simLpuart0ClockSource Clock source for the transmit and receive clock
       */
      template <typename... Types>
      constexpr ClockInit(SimLpuart0ClockSource simLpuart0ClockSource, Types... rest) : ClockInit(rest...) {
   
         sopt2 |= simLpuart0ClockSource;
      }
   
   };

   /**
    * Set TPM 0 External Clock Pin
    *
    * @param simTpm0ClkSel External pin used to drive the clock to the TPM module
    *
    * @note The selected pin must also be configured for the TPM external clock function
    * through the appropriate pin control register in the port control module
    */
   static void setTpm0ExternalClockInput(SimTpm0ClkSel simTpm0ClkSel) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_TPM0CLKSEL_MASK) | simTpm0ClkSel;
   }

   /**
    * Set TPM 1 External Clock Pin
    *
    * @param simTpm1ClkSel External pin used to drive the clock to the TPM module
    *
    * @note The selected pin must also be configured for the TPM external clock function
    * through the appropriate pin control register in the port control module
    */
   static void setTpm1ExternalClockInput(SimTpm1ClkSel simTpm1ClkSel) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_TPM1CLKSEL_MASK) | simTpm1ClkSel;
   }

   /**
    * Set TPM 1 channel 0 input capture source
    *
    * @param simTpm1Ch0Src Source for TPM channel input capture
    *        NOTE: When the TPM is not in input capture mode, clear this field
    *
    * @note The selected pin must also be configured for the TPM external clock function
    * through the appropriate pin control register in the port control module
    */
   static void setTpm1Ch0InputCaptureSource(SimTpm1Ch0Src simTpm1Ch0Src) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_TPM1CH0SRC_MASK) | simTpm1Ch0Src;
   }

   /**
    * Class used to do initialisation of Lpuart0 signals
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Lpuart0Init lpuart0Init {
    * };
    *
    * // Initialise Lpuart0 signals from values specified above
    * lpuart0Init.configure()
    * @endcode
    */
   class Lpuart0Init {
   
   public:
      /// Lpuart0 signals
      uint32_t sopt5 = 0;
   
      /**
       * Copy Constructor
       */
      constexpr Lpuart0Init(const Lpuart0Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Lpuart0Init() = default;
   
      /**
       * Constructor
       * @param simLpuart0Drive Enables Open Drain output
       * @param simLpuart0TxSrc Source for the LPUART0 transmit data
       * @param simLpuart0RxSrc Source for the LPUART0 receive data
       */
      constexpr Lpuart0Init(
            SimLpuart0Drive simLpuart0Drive,
            SimLpuart0TxSrc simLpuart0TxSrc = SimLpuart0TxSrc_Direct,
            SimLpuart0RxSrc simLpuart0RxSrc = SimLpuart0RxSrc_RxPin) {
   
         sopt5 = (sopt5 & ~(SIM_SOPT5_LPUART0ODE_MASK|SIM_SOPT5_LPUART0TXSRC_MASK|SIM_SOPT5_LPUART0RXSRC_MASK)) |
                          simLpuart0Drive|simLpuart0TxSrc|simLpuart0RxSrc;
      }
      /**
       * Configure Lpuart0 signals from values specified in constructor.
       */
      void configure() const {

         sim->SOPT5 = (sim->SOPT5&~(SIM_SOPT5_LPUART0ODE_MASK|SIM_SOPT5_LPUART0TXSRC_MASK|SIM_SOPT5_LPUART0RXSRC_MASK)) | sopt5;
      }
   /**
    * Set LPUART0 Open Drain
    *
    * @tparam   Types
    * @param    rest
    *
    * @param simLpuart0Drive Enables Open Drain output
    */
      template <typename... Types>
      constexpr Lpuart0Init(SimLpuart0Drive simLpuart0Drive, Types... rest) : Init(rest...) {
         sopt5 = (sopt5 & ~SIM_SOPT5_LPUART0ODE_MASK) | simLpuart0Drive;
   }

   /**
    * Set LPUART0 transmit data source
    *
    * @tparam   Types
    * @param    rest
    *
    * @param simLpuart0TxSrc Source for the LPUART0 transmit data
    */
      template <typename... Types>
      constexpr Lpuart0Init(SimLpuart0TxSrc simLpuart0TxSrc, Types... rest) : Init(rest...) {
         sopt5 = (sopt5 & ~SIM_SOPT5_LPUART0TXSRC_MASK) | simLpuart0TxSrc;
   }

   /**
    * Set LPUART0 receive data source
    *
    * @tparam   Types
    * @param    rest
    *
    * @param simLpuart0RxSrc Source for the LPUART0 receive data
    */
      template <typename... Types>
      constexpr Lpuart0Init(SimLpuart0RxSrc simLpuart0RxSrc, Types... rest) : Init(rest...) {
         sopt5 = (sopt5 & ~SIM_SOPT5_LPUART0RXSRC_MASK) | simLpuart0RxSrc;
   }

   };

   /**
    * Set LPUART0 Open Drain
    *
    * @param simLpuart0Drive Enables Open Drain output
    * @param simLpuart0TxSrc Source for the LPUART0 transmit data
    * @param simLpuart0RxSrc Source for the LPUART0 receive data
    */
   static void configureLpuart0(
         SimLpuart0Drive simLpuart0Drive,
         SimLpuart0TxSrc simLpuart0TxSrc = SimLpuart0TxSrc_Direct,
         SimLpuart0RxSrc simLpuart0RxSrc = SimLpuart0RxSrc_RxPin) {
      sim->SOPT5 = (sim->SOPT5&~(SIM_SOPT5_LPUART0ODE_MASK|SIM_SOPT5_LPUART0TXSRC_MASK|SIM_SOPT5_LPUART0RXSRC_MASK)) | simLpuart0Drive|simLpuart0TxSrc|simLpuart0RxSrc;
   }

   /**
    * Set LPUART0 Open Drain
    *
    * @param simLpuart0Drive Enables Open Drain output
    */
   static void setLpuart0Drive(SimLpuart0Drive simLpuart0Drive) {
      sim->SOPT5 = (sim->SOPT5&~SIM_SOPT5_LPUART0ODE_MASK) | simLpuart0Drive;
   }

   /**
    * Set LPUART0 receive data source
    *
    * @param simLpuart0RxSrc Source for the LPUART0 receive data
    */
   static void setLpuart0RxSrc(SimLpuart0RxSrc simLpuart0RxSrc) {
      sim->SOPT5 = (sim->SOPT5&~SIM_SOPT5_LPUART0RXSRC_MASK) | simLpuart0RxSrc;
   }

   /**
    * Set LPUART0 transmit data source
    *
    * @param simLpuart0TxSrc Source for the LPUART0 transmit data
    */
   static void setLpuart0TxSrc(SimLpuart0TxSrc simLpuart0TxSrc) {
      sim->SOPT5 = (sim->SOPT5&~SIM_SOPT5_LPUART0TXSRC_MASK) | simLpuart0TxSrc;
   }

   /**
    * Class used to do initialisation of Adc trigger sources
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const AdcInit adcInit {
    * };
    *
    * // Initialise Adc signals from values specified above
    * adcInit.configure()
    * @endcode
    */
   class AdcInit {
   
   public:
      /// Adc signals
      uint32_t sopt7 = 0;
   
      /**
       * Copy Constructor
       */
      constexpr AdcInit(const AdcInit &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr AdcInit() = default;
   
      /**
       * Constructor for ADC0 trigger mode
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simAdc0TriggerMode Alternative conversion triggers for ADC
       *        _Tpm              - ADC is triggered by TPM. Pre-triggers are TPM channel 0 (A) and channel 1 (B)
       *        _Alt_PreTrigger_0 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
       *        _Alt_PreTrigger_1 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
       */
      template <typename... Types>
      constexpr AdcInit(SimAdc0TriggerMode simAdc0TriggerMode, Types... rest) : AdcInit(rest...) {
   
         sopt7 = (sopt7 & ~(SIM_SOPT7_ADC0ALTTRGEN_MASK|SIM_SOPT7_ADC0PRETRGSEL_MASK)) | simAdc0TriggerMode;
      }
   
      /**
       * Constructor for ADC0 trigger mode and ADC0 trigger source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simAdc0TriggerMode Alternative conversion triggers for ADC
       *        _Tpm              - ADC is triggered by TPM. Pre-triggers are TPM channel 0 (A) and channel 1 (B)
       *        _Alt_PreTrigger_0 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
       *        _Alt_PreTrigger_1 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
       * @param simAdc0TriggerSrc  ADC Trigger source in STOP and VLPS modes, or when ADC Alternative Trigger is active
       */
      template <typename... Types>
      constexpr AdcInit(
            SimAdc0TriggerMode simAdc0TriggerMode,
            SimAdc0TriggerSrc  simAdc0TriggerSrc, Types... rest) : AdcInit(rest...) {
   
         sopt7 = (sopt7 & ~(SIM_SOPT7_ADC0ALTTRGEN_MASK|SIM_SOPT7_ADC0PRETRGSEL_MASK|SIM_SOPT7_ADC0TRGSEL_MASK)) | simAdc0TriggerMode|simAdc0TriggerSrc;
      }
   
      /**
       * Configure ADC trigger sources from values specified in constructor.
       */
      void configure() const {

         sim->SOPT7 = (sim->SOPT7&~(SIM_SOPT7_ADC0ALTTRGEN_MASK|SIM_SOPT7_ADC0PRETRGSEL_MASK|SIM_SOPT7_ADC0TRGSEL_MASK)) |
                      sopt7;
      }
   };

   /**
    * Class used to do initialisation of Adc0 trigger sources
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Adc0Init adc0Init {
    * };
    *
    * // Initialise Adc signals from values specified above
    * adc0Init.configure()
    * @endcode
    */
   class Adc0Init {
   
   public:
      /// Adc signals
      uint32_t sopt7 = 0;
   
      /**
       * Copy Constructor
       */
      constexpr Adc0Init(const Adc0Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Adc0Init() = default;
   
      /**
       * Constructor
       * @param simAdc0TriggerMode Alternative conversion triggers for ADC
       *        _Tpm              - ADC is triggered by TPM. Pre-triggers are TPM channel 0 (A) and channel 1 (B)
       *        _Alt_PreTrigger_0 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
       *        _Alt_PreTrigger_1 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
       * @param simAdc0TriggerSrc  ADC Trigger source in STOP and VLPS modes, or when ADC Alternative Trigger is active
       */
      constexpr Adc0Init(
            SimAdc0TriggerMode simAdc0TriggerMode,
            SimAdc0TriggerSrc  simAdc0TriggerSrc  = SimAdc0TriggerSrc_External) {
   
         sopt7 = simAdc0TriggerMode|simAdc0TriggerSrc;
      }
      /**
       * Configure Adc signals from values specified in constructor.
       */
      void configure() const {

         sim->SOPT7 = (sim->SOPT7&~(SIM_SOPT7_ADC0ALTTRGEN_MASK|SIM_SOPT7_ADC0PRETRGSEL_MASK|SIM_SOPT7_ADC0TRGSEL_MASK)) | sopt7;
      }
   };

   /**
    * Set ADC0 trigger mode and ADC0 trigger mode2
    *
    * @param simAdc0TriggerMode Alternative conversion triggers for ADC
    *        _Tpm              - ADC is triggered by TPM. Pre-triggers are TPM channel 0 (A) and channel 1 (B)
    *        _Alt_PreTrigger_0 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
    *        _Alt_PreTrigger_1 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
    * @param simAdc0TriggerSrc  ADC Trigger source in STOP and VLPS modes, or when ADC Alternative Trigger is active
    *
    * For example, setAdc0Triggers(SimAdc0TriggerMode_Alt_PreTrigger_1, SimAdc0Trigger_PitCh0) will set the trigger source
    * to PIT channel 0 and conversion will use SC1[1]/R[1]
    */
   static void setAdc0Triggers(
         SimAdc0TriggerMode simAdc0TriggerMode,
         SimAdc0TriggerSrc  simAdc0TriggerSrc  = SimAdc0TriggerSrc_External) {
   
      sim->SOPT7 = (sim->SOPT7&~(SIM_SOPT7_ADC0ALTTRGEN_MASK|SIM_SOPT7_ADC0PRETRGSEL_MASK|SIM_SOPT7_ADC0TRGSEL_MASK))|(simAdc0TriggerMode|simAdc0TriggerSrc);
   };

   /// COP Control Register
   static constexpr uint32_t copc = 
      SimCopDebugMode_HeldReset | // COP Debug Enable - COP is disabled and the counter is reset
      SimCopStopMode_HeldReset | // COP Stop Enable - COP is disabled and the counter is reset
      SimCopMode_Normal | // COP Windowed Mode - Normal Mode
      SimCopDuration_Disabled;  // COP Watchdog Timeout - Disabled

   /**
    * Feed COP watchdog
    */
   static void refreshCop() {
      sim->SRVCOP = 0x55;
      sim->SRVCOP = 0xAA;
   }

   /**
    * Class used to do initialisation of SIM
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    * @note Actual parameters available vary with device - see Sim::DefaultInitValue for custom example
    *
    * Example:
    * @code
    * static const Sim::Init simInit {
    *    SimErc32kClkoutPinSelect_None,            // ERCLK32K Clock Output
    *    SimErc32kSel_LpoClk,                      // ERCLK32K clock source
    *    SimUsbPower_EnabledInAll,                 // USB voltage regulator power control
    *    SimUsbFullSpeedClockSource_PeripheralClk, // USB Clock
    *    SimTraceClockoutSel_McgOutClk,            // Debug trace clock select
    *    SimRtcClkoutSel_32kHz ,                   // RTC clock out source
    *    SimClkoutSel_OscerClk0 ,                  // CLKOUT pin clock
    *    SimPeripheralClockSource_Irc48mClk ,      // Peripheral Clock
    *    SimFlexbusSecurity_None,                  // FlexBus off-chip access security level
    *    SimLpuartClockSource_PeripheralClk,       // LPUART Clock select
    *    SimTraceClockoutSel_McgOutClk,            // Debug trace clock select
    *    SimRtcClkoutSel_32kHz,                    // RTC clock out source
    *    SimClkoutSel_OscerClk0,                   // CLKOUT pin clock
    *    SimPeripheralClockSource_Irc48mClk,       // Peripheral Clock
    *    SimFlexbusSecurity_None,                  // FlexBus off-chip access security level
    *    SimFtm0Flt0_Ftm0Fault0,                   // FTM0 Fault 0 Select
    *    SimFtm0Trg0Src_Cmp0,                      // FTM0 Hardware Trigger 0 Source
    *    SimFtm0Flt1_Ftm0Fault1,                   // FTM0 Fault 1 Select
    *    SimFtm0Trg1Src_PdbTrigger1,               // FTM0 Hardware Trigger 1 Source
    *    SimFtm0ClkSel_FtmClkin0,                  // FTM0 External Clock Pin
    *    SimFtm1Flt0_Ftm1Fault0,                   // FTM1 Fault 0 Select
    *    SimFtm1Ch0Src_IcPin,                      // FTM 1 channel 0 input capture source
    *    SimFtm1ClkSel_FtmClkin0,                  // FTM1 External Clock Pin
    *    SimFtm2Flt0_Ftm2Fault0,                   // FTM2 Fault 0 Select
    *    SimFtm2Ch0Src_IcPin,                      // FTM2 channel 0 input capture source
    *    SimFtm2Ch1Src_IcPin,                      // FTM2 channel 1 input capture source
    *    SimFtm2ClkSel_FtmClkin0,                  // FTM2 External Clock Pin
    *    SimFtm3Flt0_Ftm3Fault0,                   // FTM3 Fault 0 Select
    *    SimFtm3Trg0Src_Ftm1,                      // FTM3 Hardware Trigger 0 Source
    *    SimFtm3Trg1Src_Ftm2,                      // FTM3 Hardware Trigger 1 Source
    *    SimFtm3ClkSel_FtmClkin0,                  // FTM3 External Clock Pin
    *    SimUart0RxSrc_RxPin,                      // UART 0 receive data source
    *    SimUart0TxSrc_Direct,                     // UART 0 transmit data source
    *    SimLpuart0RxSrc_RxPin,                    // LPUART 0 receive data source
    *    SimUart1RxSrc_RxPin,                      // UART 1 receive data source
    *    SimUart1TxSrc_Direct,                     // UART 1 transmit data source
    *    SimAdc0TriggerMode_Pdb ,                  // ADC0 trigger mode
    *    SimAdc0TriggerSrc_External,               // ADC0 trigger
    *    SimAdc1TriggerMode_Pdb ,                  // ADC1 trigger mode
    *    SimAdc1TriggerSrc_External,               // ADC1 trigger
    *    SimFtm0Ch0OutputSrc_Direct,               // FTM0 channel 0 output source
    *    SimFtm3Ch0OutputSrc_Direct,               // FTM3 channel 0 output source
    *    SimFtm0Ch1OutputSrc_Direct,               // FTM0 channel 1 output source
    *    SimFtm3Ch1OutputSrc_Direct,               // FTM3 channel 1 output source
    *    SimFtm0Ch2OutputSrc_Direct,               // FTM0 channel 2 output source
    *    SimFtm3Ch2OutputSrc_Direct,               // FTM3 channel 2 output source
    *    SimFtm0Ch3OutputSrc_Direct,               // FTM0 channel 3 output source
    *    SimFtm3Ch3OutputSrc_Direct,               // FTM3 channel 3 output source
    *    SimFtm0Ch4OutputSrc_Direct,               // FTM0 channel 4 output source
    *    SimFtm3Ch4OutputSrc_Direct,               // FTM3 channel 4 output source
    *    SimFtm0Ch5OutputSrc_Direct,               // FTM0 channel 5 output source
    *    SimFtm3Ch5OutputSrc_Direct,               // FTM3 channel 5 output source
    *    SimFtm0Ch6OutputSrc_Direct,               // FTM0 channel 6 output source
    *    SimFtm3Ch6OutputSrc_Direct,               // FTM3 channel 6 output source
    *    SimFtm0Ch7OutputSrc_Direct,               // FTM0 channel 7 output source
    *    SimFtm3Ch7OutputSrc_Direct,               // FTM3 channel 7 output source
    *    SimTpm1ClkSel_TpmClkin0,                  // TPM1 External Clock Pin
    *    SimTpm1Ch0Src_IcPin,                      // TPM1 channel 0 input capture source
    *    SimTpm2ClkSel_TpmClkin0,                  // TPM2 External Clock Pin
    *    SimTpm2Ch0Src_IcPin,                      // TPM2 channel 0 input capture source
    * };
    *
    * // Initialise SIM from values specified above
    * simInit.configure()
    * @endcode
    */
   class Init {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      /**
       * Configure SIM from values specified in constructor.
       */
      void configure() const {
         sim->SOPT1 = sopt1;
         sim->SOPT2 = sopt2;   // SOPT2 may also be altered by MCG clock code
         sim->SOPT4 = sopt4;
         sim->SOPT5 = sopt5;
         sim->SOPT7 = sopt7;
      }

      /// System Options Register 1
      uint32_t sopt1 = 0;

      /// System Options Register 2
      uint32_t sopt2 = 0;

      /// System Options Register 4
      uint32_t sopt4 = 0;

      /// System Options Register 5
      uint32_t sopt5 = 0;

      /// System Options Register 7
      uint32_t sopt7 = 0;

   
   public:
      /**
       * Constructor for LPUART0 Clock
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simLpuart0ClockSource Clock source for the transmit and receive clock
       */
      template <typename... Types>
      constexpr Init(SimLpuart0ClockSource simLpuart0ClockSource, Types... rest) : Init(rest...) {
   
         sopt2 |= simLpuart0ClockSource;
      }
   
      /**
       * Constructor for ERCLK32K Clock Output
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simErc32kClkoutPinSelect Outputs the ERCLK32K on the selected pin in all modes of operation
       */
      template <typename... Types>
      constexpr Init(SimErc32kClkoutPinSelect simErc32kClkoutPinSelect, Types... rest) : Init(rest...) {
   
         sopt1 |= simErc32kClkoutPinSelect;
      }
   
      /**
       * Constructor for ERCLK32K clock source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simErc32kSel Clock source for External 32k Reference Clock [ERCLK32K]
       */
      template <typename... Types>
      constexpr Init(SimErc32kSel simErc32kSel, Types... rest) : Init(rest...) {
   
         sopt1 |= simErc32kSel;
      }
   
      /**
       * Constructor for TPM Clock source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simTpmClockSource Clock source for the TPM counter clock
       */
      template <typename... Types>
      constexpr Init(SimTpmClockSource simTpmClockSource, Types... rest) : Init(rest...) {
   
         sopt2 |= simTpmClockSource;
      }
   
      /**
       * Constructor for RTC clock out source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simRtcClkoutSel Clock output on the RTC_CLKOUT pin
       */
      template <typename... Types>
      constexpr Init(SimRtcClkoutSel simRtcClkoutSel, Types... rest) : Init(rest...) {
   
         sopt2 |= simRtcClkoutSel;
      }
   
      /**
       * Constructor for CLKOUT pin clock
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simClkoutSel Clock to output on the CLKOUT pin
       */
      template <typename... Types>
      constexpr Init(SimClkoutSel simClkoutSel, Types... rest) : Init(rest...) {
   
         sopt2 |= simClkoutSel;
      }
   
      /**
       * Constructor for TPM 0 External Clock Pin
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simTpm0ClkSel External pin used to drive the clock to the TPM module
       */
      template <typename... Types>
      constexpr Init(SimTpm0ClkSel simTpm0ClkSel, Types... rest) : Init(rest...) {
   
         sopt4 |= simTpm0ClkSel;
      }
   
      /**
       * Constructor for TPM 1 channel 0 input capture source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simTpm1Ch0Src Source for TPM channel input capture
       *        NOTE: When the TPM is not in input capture mode, clear this field
       */
      template <typename... Types>
      constexpr Init(SimTpm1Ch0Src simTpm1Ch0Src, Types... rest) : Init(rest...) {
   
         sopt4 |= simTpm1Ch0Src;
      }
   
      /**
       * Constructor for TPM 1 External Clock Pin
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simTpm1ClkSel External pin used to drive the clock to the TPM module
       */
      template <typename... Types>
      constexpr Init(SimTpm1ClkSel simTpm1ClkSel, Types... rest) : Init(rest...) {
   
         sopt4 |= simTpm1ClkSel;
      }
   
      /**
       * Constructor for LPUART0 Open Drain
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simLpuart0Drive Enables Open Drain output
       */
      template <typename... Types>
      constexpr Init(SimLpuart0Drive simLpuart0Drive, Types... rest) : Init(rest...) {
   
         sopt5 |= simLpuart0Drive;
      }
   
      /**
       * Constructor for LPUART0 receive data source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simLpuart0RxSrc Source for the LPUART0 receive data
       */
      template <typename... Types>
      constexpr Init(SimLpuart0RxSrc simLpuart0RxSrc, Types... rest) : Init(rest...) {
   
         sopt5 |= simLpuart0RxSrc;
      }
   
      /**
       * Constructor for LPUART0 transmit data source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simLpuart0TxSrc Source for the LPUART0 transmit data
       */
      template <typename... Types>
      constexpr Init(SimLpuart0TxSrc simLpuart0TxSrc, Types... rest) : Init(rest...) {
   
         sopt5 |= simLpuart0TxSrc;
      }
   
      /**
       * Constructor for ADC0 trigger mode
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simAdc0TriggerMode Alternative conversion triggers for ADC
       *        _Tpm              - ADC is triggered by TPM. Pre-triggers are TPM channel 0 (A) and channel 1 (B)
       *        _Alt_PreTrigger_0 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
       *        _Alt_PreTrigger_1 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
       * @param simAdc0TriggerSrc  ADC Trigger source in STOP and VLPS modes, or when ADC Alternative Trigger is active
       */
      template <typename... Types>
      constexpr Init(
            SimAdc0TriggerMode simAdc0TriggerMode,
            SimAdc0TriggerSrc  simAdc0TriggerSrc  = SimAdc0TriggerSrc_External, Types... rest) : Init(rest...) {
   
         sopt7 |= simAdc0TriggerMode|simAdc0TriggerSrc;
      }
   
   };

};

/** 
 * End group SIM_Group
 * @}
 */
/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Abstraction for Analogue Input
 * @{
 */
/**
 * Peripheral information for ADC, Analogue Input.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * ADC Clock Source
    *
    * Clock source for the ADC module
    */
   enum AdcClockSource {
      AdcClockSource_Bus       = ADC_CFG1_ADICLK(0), ///< Bus clock
      AdcClockSource_Irc48mClk = ADC_CFG1_ADICLK(1), ///< Irc48M clock
      AdcClockSource_OscerClk  = ADC_CFG1_ADICLK(2), ///< Alternate clock (OSCERCLK)
      AdcClockSource_Asynch    = ADC_CFG1_ADICLK(3), ///< Asynchronous clock (ADACK)

   };

   /**
    * Clock Divide Select
    *
    * Selects the divide ratio used by the ADC to generate the internal clock ADCK
    */
   enum AdcClockDivider {
      AdcClockDivider_1 = ADC_CFG1_ADIV(0), ///< Divide by 1
      AdcClockDivider_2 = ADC_CFG1_ADIV(1), ///< Divide by 2
      AdcClockDivider_4 = ADC_CFG1_ADIV(2), ///< Divide by 4
      AdcClockDivider_8 = ADC_CFG1_ADIV(3), ///< Divide by 8

   };

   /**
    * ADC Resolution
    *
    * The resolutions available vary with single-ended/differential modes
    * Note the equivalence between modes e.g. 8-bit-se = 9-bit-diff
    */
   enum AdcResolution {
      AdcResolution_8bit_se  = ADC_CFG1_MODE(0), ///< 8-bit unsigned (single-ended mode)
      AdcResolution_10bit_se = ADC_CFG1_MODE(2), ///< 10-bit unsigned (single-ended mode)
      AdcResolution_12bit_se = ADC_CFG1_MODE(1), ///< 12-bit unsigned (single-ended mode)

   };

   /**
    * Low-Power Configuration
    *
    * Adjust power consumption
    */
   enum AdcPower {
      AdcPower_Normal = ADC_CFG1_ADLPC(0), ///< Normal power configuration
      AdcPower_Low    = ADC_CFG1_ADLPC(1), ///< Low-power configuration (reduced speed)

   };

   /**
    * Long Sample Time Select
    *
    * Selects sample times 
    * Longer times allow higher impedance inputs to be accurately sampled or
    * shorter times maximize conversion speed for lower impedance inputs
    * It also affects the conversion rate and power consumption for continuous mode
    */
   enum AdcSample {
      AdcSample_4  = (ADC_CFG1_ADLSMP(0)),                    ///< 4 ADCK total
      AdcSample_6  = (ADC_CFG1_ADLSMP(1)|ADC_CFG2_ADLSTS(3)), ///< +2 ADCK cycles; 6 ADCK total
      AdcSample_10 = (ADC_CFG1_ADLSMP(1)|ADC_CFG2_ADLSTS(2)), ///< +6 ADCK cycles; 10 ADCK total
      AdcSample_16 = (ADC_CFG1_ADLSMP(1)|ADC_CFG2_ADLSTS(1)), ///< +12 ADCK cycles; 16 ADCK total
      AdcSample_24 = (ADC_CFG1_ADLSMP(1)|ADC_CFG2_ADLSTS(0)), ///< +20 ADCK cycles; 24 ADCK total

   };

   /**
    * Hardware Average Select
    *
    * Determines how many ADC conversions will be averaged
    * by the hardware to create the ADC result
    */
   enum AdcAveraging {
      AdcAveraging_off = ADC_SC3_CAL(0)|ADC_SC3_CALF(0)|ADC_SC3_AVGE(0)|ADC_SC3_AVGS(0), ///< 1 sample
      AdcAveraging_4   = ADC_SC3_CAL(0)|ADC_SC3_CALF(0)|ADC_SC3_AVGE(1)|ADC_SC3_AVGS(0), ///< 4 samples
      AdcAveraging_8   = ADC_SC3_CAL(0)|ADC_SC3_CALF(0)|ADC_SC3_AVGE(1)|ADC_SC3_AVGS(1), ///< 8 samples
      AdcAveraging_16  = ADC_SC3_CAL(0)|ADC_SC3_CALF(0)|ADC_SC3_AVGE(1)|ADC_SC3_AVGS(2), ///< 16 samples
      AdcAveraging_32  = ADC_SC3_CAL(0)|ADC_SC3_CALF(0)|ADC_SC3_AVGE(1)|ADC_SC3_AVGS(3), ///< 32 samples
      AdcAveraging_Cal = ADC_SC3_CAL(1)|ADC_SC3_CALF(1)|ADC_SC3_AVGE(1)|ADC_SC3_AVGS(3), ///< 32 samples + clear flag + start calibration

   };

   /**
    * High-Speed Configuration
    *
    * Configures the ADC for high-speed clock operation
    * This actually extends the number of conversion clock cycles
    * but is offset by allowing a faster input clock
    */
   enum AdcClockRange {
      AdcClockRange_Normal = ADC_CFG2_ADHSC(0), ///< Normal conversion sequence selected
      AdcClockRange_High   = ADC_CFG2_ADHSC(1), ///< High-speed conversion sequence selected

   };

   /**
    * Asynchronous Clock Output Enable
    *
    * Enables the ADC internal asynchronous clock source irrespective of ADC need.
    * This reduces the initial delay at the start of a sequence of conversions.
    * It also allows use of the ADC internal clock as a clock source for other peripherals
    */
   enum AdcAsyncClock {
      AdcAsyncClock_Disabled = ADC_CFG2_ADACKEN(0), ///< Asynchronous clock output disabled
      AdcAsyncClock_Enabled  = ADC_CFG2_ADACKEN(1), ///< Asynchronous clock output enabled

   };

   /**
    * Voltage Reference Selection
    *
    * Selects the voltage reference source used for conversions
    */
   enum AdcRefSel {
      AdcRefSel_VrefHL  = ADC_SC2_REFSEL(0), ///< VRefH and VRefl
      AdcRefSel_VrefOut = ADC_SC2_REFSEL(1), ///< Gnd and VrefOut(1.2V)
      AdcRefSel_Default = ADC_SC2_REFSEL(0), ///< Default

   };

   /**
    * Enables conversion interrupts
    *
    * An interrupt is triggered at the end of each conversion
    */
   enum AdcInterrupt {
      AdcInterrupt_Disabled = ADC_SC1_AIEN(0), ///< Disabled
      AdcInterrupt_Enabled  = ADC_SC1_AIEN(1), ///< Enabled

   };

   /**
    * Selects the pretrigger
    *
    * Selects which SC1[x]/R[x] register pair to use
    */
   enum AdcPretrigger {
      AdcPretrigger_0 = (0), ///< Use pretrigger 0 = SC1[0]/R[0]
      AdcPretrigger_1 = (1), ///< Use pretrigger 1 = SC1[1]/R[1]

   };

   /**
    * Selects between A/B multiplexor inputs on some ADC channels
    *
    * Some ADC inputs may be multiplexed to two pins e.g. adcCh4a and adcCh4b
    */
   enum AdcMuxsel {
      AdcMuxsel_A = ADC_CFG2_MUXSEL(0), ///< The multiplexor selects A channels
      AdcMuxsel_B = ADC_CFG2_MUXSEL(1), ///< The multiplexor selects B channels

   };

   /**
    * Selects between single and continuous conversion
    *
    * When enabled, continuous conversion are triggered when the first conversion is initiated
    */
   enum AdcContinuous {
      AdcContinuous_Disabled = ADC_SC3_ADCO(0), ///< Single conversion on each trigger
      AdcContinuous_Enabled  = ADC_SC3_ADCO(1), ///< Continuous conversions after 1st trigger

   };

   /**
    * Compare function
    *
    * Enables comparison of ADC result with CV1 and CV2
    */
   enum AdcCompare {
      AdcCompare_Disabled              = ADC_SC2_ACFE(0)|ADC_SC2_ACREN(0)|ADC_SC2_ACFGT(0)|(0),      ///< No comparison done
      AdcCompare_LessThan              = ADC_SC2_ACFE(1)|ADC_SC2_ACREN(0)|ADC_SC2_ACFGT(0)|(0),      ///< ADC value < low
      AdcCompare_GreaterThanOrEqual    = ADC_SC2_ACFE(1)|ADC_SC2_ACREN(0)|ADC_SC2_ACFGT(1)|(0),      ///< ADC value >= low
      AdcCompare_OutsideRangeExclusive = ADC_SC2_ACFE(1)|ADC_SC2_ACREN(1)|ADC_SC2_ACFGT(0)|((0<<8)), ///< (ADC value < low) or (ADC value > high)
      AdcCompare_OutsideRangeInclusive = ADC_SC2_ACFE(1)|ADC_SC2_ACREN(1)|ADC_SC2_ACFGT(1)|((1<<8)), ///< (ADC value <= low) or (ADC value >= high)
      AdcCompare_InsideRangeExclusive  = ADC_SC2_ACFE(1)|ADC_SC2_ACREN(1)|ADC_SC2_ACFGT(0)|((1<<8)), ///< (low < ADC value < high)
      AdcCompare_InsideRangeInclusive  = ADC_SC2_ACFE(1)|ADC_SC2_ACREN(1)|ADC_SC2_ACFGT(1)|((0<<8)), ///< (low <= ADC value <= high)

   };

   /**
    * Conversion Trigger Select
    *
    * Selects the type of trigger used for initiating a conversion
    */
   enum AdcTrigger {
      AdcTrigger_Software = ADC_SC2_ADTRG(0), ///< Software trigger (write to SC1A)
      AdcTrigger_Hardware = ADC_SC2_ADTRG(1), ///< Hardware trigger (ADHWT source)

   };

class Adc0BasicInfo {
   
public:
   /**
    * Type definition for Adc0 interrupt call back.
    *
    * @param[in] result  Conversion result from channel
    * @param[in] channel Channel providing the result
    */
   typedef void (*CallbackFunction)(uint32_t result, int channel);

   /**
    * Class used to do initialisation of Adc0
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * // Initialisation values for Adc0
    * // Options available vary with device - See Adc0::DefaultInitValue for example
    * static const Adc0::Init adcInit {
    *
    *    // Omitted parameters are take to be zero unless an base value is given
    *    AdcClockSource_Asynch ,  // ADC Clock Source
    *    AdcClockDivider_1 ,      // Clock Divide Select
    *    AdcResolution_8bit_se ,  // ADC Resolution
    *    AdcPower_Normal ,        // Low-Power Configuration
    *    AdcClockRange_Normal ,   // High-Speed Configuration
    *    AdcAsyncClock_Disabled , // Asynchronous Clock Output Enable
    *    AdcRefSel_VrefHL ,       // Voltage Reference Selection
    *    AdcDma_Disabled ,        // DMA Enable
    *    AdcMuxsel_B ,            // Selects between A/B multiplexor inputs on some ADC channels
    *    AdcInterrupt_Disabled ,  // Enables conversion interrupts
    *    AdcDma_Disabled ,        // DMA Enable
    *    AdcTrigger_Software ,    // Conversion Trigger Select
    *    AdcAveraging_off ,       // Hardware Average Select
    *    AdcContinuous_Disabled , // Selects between single and continuous conversion
    *    NvicPriority_Normal ,    // IRQ level for this peripheral
    *    adcCallback,             // Call-back to execute on completion
    *
    *    // These 2/3 parameters must appear in this order
    *    AdcCompare_LessThan ,    // Compare function
    *    5000 ,                   // ADC CV low value
    *    6000 ,                   // ADC CV high value (May be omitted)
   
    *    // Optional base value to start with (must be last parameter)
    *    Adc0::DefaultValue
    * };
    *
    * // Initialise ADC from values specified above
    * Adc0::configure(adcInit);
    * Adc0::calibrate();
    * @endcode
    */
   class Init {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      /// Peripheral interrupt handling
      CallbackFunction callbackFunction = nullptr;

      ///  ADC CV low value
      uint16_t cv1 = 0;

      ///  ADC CV high value
      uint16_t cv2 = 0;

      ///  ADC Configuration Register 1
      uint8_t cfg1 = 0;

      ///  ADC Configuration Register 2
      uint8_t cfg2 = 0;

      ///  ADC Status and Control Registers 2
      uint8_t sc2 = 0;

      ///  ADC Status and Control Registers 3
      uint8_t sc3 = 0;

      /// IRQ priority levels
      NvicPriority irqlevel = NvicPriority_Normal;

      /**
       * Constructor for Peripheral interrupt handling
       *
       * @tparam   Types
       * @param    rest
       * @param callbackFunction If enabled, the handler may be set using the setCallback() function or
       *        by overriding the interrupt handler method in the peripheral class
       *        If not enabled, then interrupt handlers may be installed by naming them 
       *        (see weak names used in vector table).
       */
      template <typename... Types>
      constexpr Init(CallbackFunction callbackFunction, Types... rest) : Init(rest...) {
   
         this->callbackFunction = callbackFunction;
      }

      /**
       * Constructor for IRQ priority levels
       *
       * @tparam   Types
       * @param    rest
       * @param nvicPriority Priority level used to configure the NVIC
       *        Subset of available levels
       */
      template <typename... Types>
      constexpr Init(NvicPriority nvicPriority, Types... rest) : Init(rest...) {
   
#if true
         irqlevel = nvicPriority;
#else
         (void)nvicPriority;
#endif
      }

      /**
       * Constructor for ADC Clock Source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcClockSource Clock source for the ADC module
       */
      template <typename... Types>
      constexpr Init(AdcClockSource adcClockSource, Types... rest) : Init(rest...) {
   
         cfg1 = (cfg1&~ADC_CFG1_ADICLK_MASK) | adcClockSource;
      }
   
      /**
       * Constructor for Clock Divide Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcClockDivider Selects the divide ratio used by the ADC to generate the internal clock ADCK
       */
      template <typename... Types>
      constexpr Init(AdcClockDivider adcClockDivider, Types... rest) : Init(rest...) {
   
         cfg1 = (cfg1&~ADC_CFG1_ADIV_MASK) | adcClockDivider;
      }
   
      /**
       * Constructor for ADC Resolution
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcResolution The resolutions available vary with single-ended/differential modes
       *        Note the equivalence between modes e.g. 8-bit-se = 9-bit-diff
       */
      template <typename... Types>
      constexpr Init(AdcResolution adcResolution, Types... rest) : Init(rest...) {
   
         cfg1 = (cfg1&~ADC_CFG1_MODE_MASK) | adcResolution;
      }
   
      /**
       * Constructor for Low-Power Configuration
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcPower Adjust power consumption
       */
      template <typename... Types>
      constexpr Init(AdcPower adcPower, Types... rest) : Init(rest...) {
   
         cfg1 = (cfg1&~ADC_CFG1_ADLPC_MASK) | adcPower;
      }
   
      /**
       * Constructor for High-Speed Configuration
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcClockRange Configures the ADC for high-speed clock operation
       *        This actually extends the number of conversion clock cycles
       *        but is offset by allowing a faster input clock
       */
      template <typename... Types>
      constexpr Init(AdcClockRange adcClockRange, Types... rest) : Init(rest...) {
   
         cfg2 = (cfg2&~ADC_CFG2_ADHSC_MASK) | adcClockRange;
      }
   
      /**
       * Constructor for Asynchronous Clock Output Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcAsyncClock Enables the ADC internal asynchronous clock source irrespective of ADC need.
       *        This reduces the initial delay at the start of a sequence of conversions.
       *        It also allows use of the ADC internal clock as a clock source for other peripherals
       */
      template <typename... Types>
      constexpr Init(AdcAsyncClock adcAsyncClock, Types... rest) : Init(rest...) {
   
         cfg2 = (cfg2&~ADC_CFG2_ADACKEN_MASK) | adcAsyncClock;
      }
   
      /**
       * Constructor for Selects between A/B multiplexor inputs on some ADC channels
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcMuxsel Some ADC inputs may be multiplexed to two pins e.g. adcCh4a and adcCh4b
       */
      template <typename... Types>
      constexpr Init(AdcMuxsel adcMuxsel, Types... rest) : Init(rest...) {
   
         cfg2 = (cfg2&~ADC_CFG2_MUXSEL_MASK) | adcMuxsel;
      }
   
      /**
       * Constructor for Voltage Reference Selection
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcRefSel Selects the voltage reference source used for conversions
       */
      template <typename... Types>
      constexpr Init(AdcRefSel adcRefSel, Types... rest) : Init(rest...) {
   
         sc2 = (sc2&~ADC_SC2_REFSEL_MASK) | adcRefSel;
      }
   
      /**
       * Constructor for Conversion Trigger Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcTrigger Selects the type of trigger used for initiating a conversion
       */
      template <typename... Types>
      constexpr Init(AdcTrigger adcTrigger, Types... rest) : Init(rest...) {
   
         sc2 = (sc2&~ADC_SC2_ADTRG_MASK) | adcTrigger;
      }
   
      /**
       * Constructor for Hardware Average Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcAveraging Determines how many ADC conversions will be averaged
       *        by the hardware to create the ADC result
       */
      template <typename... Types>
      constexpr Init(AdcAveraging adcAveraging, Types... rest) : Init(rest...) {
   
         sc3 = (sc3&~(ADC_SC3_CAL_MASK|ADC_SC3_CALF_MASK|ADC_SC3_AVGE_MASK|ADC_SC3_AVGS_MASK)) | adcAveraging;
      }
   
      /**
       * Constructor for Selects between single and continuous conversion
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcContinuous When enabled, continuous conversion are triggered when the first conversion is initiated
       */
      template <typename... Types>
      constexpr Init(AdcContinuous adcContinuous, Types... rest) : Init(rest...) {
   
         sc3 = (sc3&~ADC_SC3_ADCO_MASK) | adcContinuous;
      }
   
      /**
       * Configure Compare function, ADC CV low value and ADC CV high value
       *
       * @tparam   Types
       * @param    rest
       *
       * @param[in] adcCompare   Comparison operation to enable
       * @param[in] low          Lower threshold
       * @param[in] high         Higher threshold (if needed)
       */
      template <typename... Types>
      constexpr Init(AdcCompare adcCompare, int low, int high=0, Types... rest) : Init(rest...) {
   
         // Juggle CV1, CV2 values to satisfy comparison rules
         switch (adcCompare) {
            case AdcCompare_Disabled:
               break;
            case AdcCompare_LessThan:
            case AdcCompare_GreaterThanOrEqual:
               cv1 = low;
               break;
            case AdcCompare_OutsideRangeExclusive:
            case AdcCompare_InsideRangeInclusive:
               cv1 = low;
               cv2 = high;
               break;
            case AdcCompare_InsideRangeExclusive:
            case AdcCompare_OutsideRangeInclusive:
               cv1 = high;
               cv2 = low;
               break;
         }
         sc2 = (sc2&~((ADC_SC2_ACFE_MASK|ADC_SC2_ACREN_MASK|ADC_SC2_ACFGT_MASK))) | adcCompare;
      }
   
   };
};

class Adc0Info {
public:
   /*
    * Template:adc0_mkl
    */
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = ADC0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<ADC_Type> adc = baseAddress;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = ADC0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = true;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_Normal;

   /**
    * Get ADC Clock Source
    *
    * @param adcClockSource Clock source for the ADC module
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getAdcClock(AdcClockSource adcClockSource) {
   
      switch(adcClockSource) {
         default: return 0;
         case AdcClockSource_Bus       : return SystemBusClock;            ///< Bus clock
         case AdcClockSource_Irc48mClk : return SimInfo::irc48mClock;      ///< Irc48M clock
         case AdcClockSource_OscerClk  : return Osc0Info::getOscerClock(); ///< Alternate clock (OSCERCLK)
         case AdcClockSource_Asynch    : return 5200000;       ///< Asynchronous clock (ADACK)

      }
   }

   /**
    * Class used to do initialisation of Adc0
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * // Initialisation values for Adc0
    * // Options available vary with device - See Adc0::DefaultInitValue for example
    * static const Adc0::Init adcInit {
    *
    *    // Omitted parameters are take to be zero unless an base value is given
    *    AdcClockSource_Asynch ,  // ADC Clock Source
    *    AdcClockDivider_1 ,      // Clock Divide Select
    *    AdcResolution_8bit_se ,  // ADC Resolution
    *    AdcPower_Normal ,        // Low-Power Configuration
    *    AdcClockRange_Normal ,   // High-Speed Configuration
    *    AdcAsyncClock_Disabled , // Asynchronous Clock Output Enable
    *    AdcRefSel_VrefHL ,       // Voltage Reference Selection
    *    AdcDma_Disabled ,        // DMA Enable
    *    AdcMuxsel_B ,            // Selects between A/B multiplexor inputs on some ADC channels
    *    AdcInterrupt_Disabled ,  // Enables conversion interrupts
    *    AdcDma_Disabled ,        // DMA Enable
    *    AdcTrigger_Software ,    // Conversion Trigger Select
    *    AdcAveraging_off ,       // Hardware Average Select
    *    AdcContinuous_Disabled , // Selects between single and continuous conversion
    *    NvicPriority_Normal ,    // IRQ level for this peripheral
    *    adcCallback,             // Call-back to execute on completion
    *
    *    // These 2/3 parameters must appear in this order
    *    AdcCompare_LessThan ,    // Compare function
    *    5000 ,                   // ADC CV low value
    *    6000 ,                   // ADC CV high value (May be omitted)
   
    *    // Optional base value to start with (must be last parameter)
    *    Adc0::DefaultValue
    * };
    *
    * // Initialise ADC from values specified above
    * Adc0::configure(adcInit);
    * Adc0::calibrate();
    * @endcode
    */
   typedef Adc0BasicInfo::Init Init;
   
   /**
    * Adc0 interrupt call back
    */
   typedef Adc0BasicInfo::CallbackFunction CallbackFunction;
   
   /**
    * Default initialisation value for Adc0
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr Init DefaultInitValue = {
      AdcClockSource_Irc48mClk , // ADC Clock Source - Irc48M clock
      AdcClockDivider_8 , // Clock Divide Select - Divide by 8
      AdcResolution_8bit_se , // ADC Resolution - 8-bit unsigned (single-ended mode)
      AdcPower_Normal , // Low-Power Configuration - Normal power configuration
      AdcClockRange_Normal , // High-Speed Configuration - Normal conversion sequence selected
      AdcAsyncClock_Disabled , // Asynchronous Clock Output Enable - Asynchronous clock output disabled
      AdcRefSel_VrefHL , // Voltage Reference Selection - VRefH and VRefl
      AdcMuxsel_B , // Selects between A/B multiplexor inputs on some ADC channels - The multiplexor selects B channels
      AdcTrigger_Software , // Conversion Trigger Select - Software trigger (write to SC1A)
      AdcAveraging_off , // Hardware Average Select - 1 sample
      AdcContinuous_Disabled , // Selects between single and continuous conversion - Single conversion on each trigger
      NvicPriority_Normal , // IRQ level for this peripheral - Normal
      AdcCompare_Disabled , // Compare function - No comparison done
      0 , // ADC CV low value
      0,  // ADC CV high value
   };

   /** 
    *  Enable clock to Adc0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableAdc0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_ADC0_MASK;
#endif
   }

   /** 
    *  Disable clock to Adc0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableAdc0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_ADC0_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 16;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: ADC0_SE0             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: ADC0_SE1             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: ADC0_SE2             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: ADC0_SE3             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   5: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   6: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   7: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   8: ADC0_SE8             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   9: ADC0_SE9             = PTB0(p8)                       */  { PortBInfo,  0,            (PcrValue)0x00000UL  },
         /*  10: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  11: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  12: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  13: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  14: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  15: ADC0_SE15            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTB_CLOCK_MASK);
#endif

   PORTB->GPCLR = 0x0000UL|PORT_GPCLR_GPWE(0x0001UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTB_CLOCK_MASK);
#endif

   PORTB->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0001UL);
   }

};

/** 
 * End group ADC_Group
 * @}
 */
/**
 * @addtogroup CMP_Group CMP, Analogue Comparator
 * @brief Abstraction for Analogue Comparator
 * @{
 */
/**
 * Peripheral information for CMP, Analogue Comparator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Plus Input Mux Control
    *
    * Determines which input is selected for the plus input of the comparator
    */
   enum Cmp0InputPlus {
      Cmp0InputPlus_0 = CMP_MUXCR_PSEL(0), ///< CMP_IN0
      Cmp0InputPlus_1 = CMP_MUXCR_PSEL(1), ///< CMP_IN1
      Cmp0InputPlus_2 = CMP_MUXCR_PSEL(2), ///< CMP_IN2
      Cmp0InputPlus_3 = CMP_MUXCR_PSEL(3), ///< CMP_IN3
      Cmp0InputPlus_4 = CMP_MUXCR_PSEL(4), ///< CMP_IN4/12-bit DAC1
      Cmp0InputPlus_5 = CMP_MUXCR_PSEL(5), ///< CMP_IN5/VREF_OUT
      Cmp0InputPlus_6 = CMP_MUXCR_PSEL(6), ///< Bandgap
      Cmp0InputPlus_7 = CMP_MUXCR_PSEL(7), ///< 6-bit DAC reference

   };

   /**
    * Minus Input Mux Control
    *
    * Determines which input is selected for the minus input of the comparator
    */
   enum Cmp0InputMinus {
      Cmp0InputMinus_0 = CMP_MUXCR_MSEL(0), ///< CMP_IN0
      Cmp0InputMinus_1 = CMP_MUXCR_MSEL(1), ///< CMP_IN1
      Cmp0InputMinus_2 = CMP_MUXCR_MSEL(2), ///< CMP_IN2
      Cmp0InputMinus_3 = CMP_MUXCR_MSEL(3), ///< CMP_IN3
      Cmp0InputMinus_4 = CMP_MUXCR_MSEL(4), ///< CMP_IN4/12-bit DAC1
      Cmp0InputMinus_5 = CMP_MUXCR_MSEL(5), ///< CMP_IN5/VREF_OUT
      Cmp0InputMinus_6 = CMP_MUXCR_MSEL(6), ///< Bandgap
      Cmp0InputMinus_7 = CMP_MUXCR_MSEL(7), ///< 6-bit DAC reference

   };

   /**
    * Action on transition
    *
    * Enables interrupt request on comparator transition
    */
   enum CmpEvent {
      CmpEvent_Disabled  = CMP_SCR_IER(0)|CMP_SCR_IEF(0), ///< Disabled
      CmpEvent_OnRising  = CMP_SCR_IER(1)|CMP_SCR_IEF(1), ///< Rising edge
      CmpEvent_OnFalling = CMP_SCR_IER(1)|CMP_SCR_IEF(0), ///< Falling edge
      CmpEvent_OnEither  = CMP_SCR_IER(1)|CMP_SCR_IEF(0), ///< Either edge

   };

   /**
    * Comparator hard block hysteresis control
    *
    * Defines the programmable hysteresis level.
    * The hysteresis values associated with each level are device specific
    */
   enum CmpHysteresis {
      CmpHysteresis_Level_0 = CMP_CR0_HYSTCTR(0), ///< Level 0
      CmpHysteresis_Level_1 = CMP_CR0_HYSTCTR(1), ///< Level 1
      CmpHysteresis_Level_2 = CMP_CR0_HYSTCTR(2), ///< Level 2
      CmpHysteresis_Level_3 = CMP_CR0_HYSTCTR(3), ///< Level 3

   };

   /**
    * Power Mode Select
    *
    * Selects trade-off between speed and power consumption
    */
   enum CmpPower {
      CmpPower_LowSpeed  = CMP_CR1_PMODE(0), ///< Low-Speed Comparison mode
      CmpPower_HighSpeed = CMP_CR1_PMODE(1), ///< High-Speed Comparison mode

   };

   /**
    * Comparator Invert
    *
    * Allows selection of the polarity of the analog comparator function
    */
   enum CmpPolarity {
      CmpPolarity_Normal   = CMP_CR1_INV(0), ///< Not inverted
      CmpPolarity_Inverted = CMP_CR1_INV(1), ///< Inverted

   };

   /**
    * Trigger Mode Enable
    *
    * CMP and DAC are configured to CMP Trigger mode.  
    * CMP Trigger mode depends on an external timer resource to periodically enable 
    * Upon setting TRIGM, the CMP and DAC are placed in a standby state until an 
    * external timer resource trigger is received.
    */
   enum CmpTrigger {
      CmpTrigger_Disabled = CMP_CR1_TRIGM(0), ///< Trigger mode is disabled
      CmpTrigger_Enabled  = CMP_CR1_TRIGM(1), ///< Trigger mode is enabled

   };

   /**
    * Comparator output pin source
    *
    * Selects whether the output pin is driven by the filtered or unfiltered comparator output
    */
   enum CmpOutput {
      CmpOutput_Disabled = CMP_CR1_OPE(0)|CMP_CR1_COS(0), ///< Disabled
      CmpOutput_Direct   = CMP_CR1_OPE(1)|CMP_CR1_COS(1), ///< Direct (unfiltered)
      CmpOutput_Filtered = CMP_CR1_OPE(1)|CMP_CR1_COS(0), ///< Filtered

   };

   /**
    * DAC Enable
    *
    * Enables the internal DAC
    */
   enum CmpDacEnable {
      CmpDacEnable_Disabled = CMP_DACCR_DACEN(0), ///< Disabled
      CmpDacEnable_Enabled  = CMP_DACCR_DACEN(1), ///< Enabled

   };

   /**
    * DAC Reference Voltage Select
    *
    * Supply Voltage Reference Source Select
    */
   enum CmpDacrefSel {
      CmpDacrefSel_VrefOut = CMP_DACCR_VRSEL(0), ///< Vin1 (Vref_OUT)
      CmpDacrefSel_Vdd     = CMP_DACCR_VRSEL(1), ///< Vin2 (Vdd)

   };

   /**
    * Comparator Filtering Mode
    *
    * Disabled
    * Comparator is non-functional and consumes no power.
    * CMPO is 0 in this mode.
    * 
    * Mode 2a/b - Continuous mode
    * CMPO is not subject to sampling or filtering. 
    * Both window control and filter blocks are completely bypassed.  
    * SCR[COUT] is updated continuously.  
    * The path from comparator input pins is operating in combinational unclocked mode. 
    * 
    * Mode 3a/b - Sampled, Non-Filtered mode
    * CMPO is not subject to sampling or filtering.  
    * Window control is bypassed. The filter block operates as a simple Sample & Hold 
    * 3a/b selects between clock sources for the Sample & Hold 
    * In 3a the external window/sample input is used to clock the Sample & Hold clock 
    * In 3b FILT_PER acts as a prescaler for bus clock driving the Sample & Hold clock 
    * 
    * Mode 4a/b - Sampled, Filtered mode
    * As for 3a/b but the filter is enabled (FILTER_CNT>1) rather than acting as a simple S&H
    * 
    * Mode 5a/b - Windowed mode
    * The comparator output is qualified by an external window signal. 
    * When enabled, the comparator output is clocked by the bus clock and held when not enabled. 
    * This introduces up to 1 clock delay.
    * 
    * Mode 6 - Windowed/Resampled mode
    * The comparator output is qualified by an external window signal. 
    * When enabled, the comparator output is clocked by the bus clock and then resampled at a 
    * rate determined by the FILT_PER to generate COUT. 
    * 
    * Mode 7 - Windowed/Filtered mode
    * The comparator output is qualified by an external window signal. 
    * When enabled, the comparator output is clocked by the bus clock and then filtered at a 
    * sample rate determined by the FILT_PER to generate COUT.
    * FILTER_CNT determines the filter sample count (width)
    */
   enum CmpFilterMode {
      CmpFilterMode_Disabled             = 0, ///< 1    Disabled
      CmpFilterMode_Continuous           = 1, ///< 2a/b Continuous
      CmpFilterMode_External_NonFiltered = 2, ///< 3a   Externally sampled, Non-Filtered
      CmpFilterMode_Internal_NonFiltered = 3, ///< 3b   Internally sampled, Non-Filtered
      CmpFilterMode_External_Filtered    = 4, ///< 4a   Externally sampled, Filtered
      CmpFilterMode_Internal_Filtered    = 5, ///< 4b   Internally sampled, Filtered
      CmpFilterMode_Windowed             = 6, ///< 5a/b Windowed
      CmpFilterMode_Windowed_Resampled   = 7, ///< 6    Windowed, Re-sampled
      CmpFilterMode_Windowed_Filtered    = 8, ///< 7    Windowed, Filtered

   };

   /**
    * Comparator Enable
    *
    * Enable comparator
    */
   enum CmpEnable {
      CmpEnable_Disabled = CMP_CR1_EN(0), ///< Comparator is disabled
      CmpEnable_Enabled  = CMP_CR1_EN(1), ///< Comparator is enabled

   };

   /**
    * Windowing Enable
    *
    * Enable the use of an external signal to qualify the comparator output (before filtering).
    * The comparator output is held when the external signal is inactive and
    * clocked directly by the bus clock when enabled.
    * Usually a PDB output is available for this purpose.
    */
   enum CmpWindowEnable {
      CmpWindowEnable_Disabled = CMP_CR1_WE(0), ///< Disabled
      CmpWindowEnable_Enabled  = CMP_CR1_WE(1), ///< Enabled

   };

   /**
    * Sample Enable
    *
    * Select between the divided bus clock and an external clock for the filter block
    */
   enum CmpSampleEnable {
      CmpSampleEnable_Internal = CMP_CR1_SE(0), ///< Internal clock
      CmpSampleEnable_External = CMP_CR1_SE(1), ///< External clock

   };

   /**
    * Filter Sample Count
    *
    * Represents the number of consecutive samples that must agree prior 
    * to the comparator output filter accepting a new output state
    */
   enum CmpFilterSamples {
      CmpFilterSamples_Bypassed       = CMP_CR0_FILTER_CNT(0), ///< Disabled
      CmpFilterSamples_SimpleSampling = CMP_CR0_FILTER_CNT(1), ///< Simple sampling
      CmpFilterSamples_2              = CMP_CR0_FILTER_CNT(2), ///< 2 samples must agree
      CmpFilterSamples_3              = CMP_CR0_FILTER_CNT(3), ///< 3 samples must agree
      CmpFilterSamples_4              = CMP_CR0_FILTER_CNT(4), ///< 4 samples must agree
      CmpFilterSamples_5              = CMP_CR0_FILTER_CNT(5), ///< 5 samples must agree
      CmpFilterSamples_6              = CMP_CR0_FILTER_CNT(6), ///< 6 samples must agree
      CmpFilterSamples_7              = CMP_CR0_FILTER_CNT(7), ///< 7 samples must agree

   };

   /**
    * Operating mode
    *
    * Selects operation in sampling or windowed mode
    */
   enum CmpMode {
      CmpMode_Direct   = CMP_CR1_SE(0)|CMP_CR1_WE(0), ///< Direct
      CmpMode_Sampling = CMP_CR1_SE(1)|CMP_CR1_WE(0), ///< Sampling mode
      CmpMode_Windowed = CMP_CR1_SE(0)|CMP_CR1_WE(1), ///< Windowing mode

   };

   /**
    * Comparator event identification
    */
   enum CmpEventId : uint8_t {
      CmpEventId_None    = CMP_SCR_CFR(0)|CMP_SCR_CFF(0),  //!< Neither edge
      CmpEventId_Rising  = CMP_SCR_CFR(1)|CMP_SCR_CFF(0),  //!< Rising edge
      CmpEventId_Falling = CMP_SCR_CFR(0)|CMP_SCR_CFF(1),  //!< Falling edge
      CmpEventId_Both    = CMP_SCR_CFR(1)|CMP_SCR_CFF(1),  //!< Rising or falling edge
   };
   
   /**
    * Used to represent the comparator status for interrupt handler
    */
   struct CmpStatus {
      CmpEventId event:8;   //!< Event triggering handler
      bool       state:8;   //!< State of CMPO at event
   
      constexpr CmpStatus(CmpEventId event, uint8_t  state) : event(event), state(state) {}
   };
   
class Cmp0BasicInfo {
   
public:
   
   
   /**
    * Type definition for Cmp0 interrupt call back.
    */
   typedef void (*CallbackFunction)(const CmpStatus &);
   
   /**
    * Class used to do initialisation of the Cmp0
    *
    * This class has a templated constructor that accepts various values.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Cmp0::Init init {
    *
    *   // General setup
    *   CmpEnable_Enabled ,          // Comparator Enable - Comparator is enabled
    *   CmpMode_Direct ,             // Operating mode - Direct
    *   CmpTrigger_Enabled ,         // Trigger Mode Enable - Trigger mode is enabled
    *   CmpPower_HighSpeed ,         // Power Mode Select - High-Speed Comparison mode
    *   CmpPolarity_Inverted ,       // Comparator Invert - Inverted
    *   CmpOutput_Direct ,           // Comparator output pin source - Direct (unfiltered)
    *   CmpHysteresis_Level_2 ,      // Comparator hard block hysteresis control - Level 2
    *   CmpDma_Disabled ,            // DMA Enable Control - Disabled
    *
    *   // Interrupt handling - must be in this order
    *   CmpEvent_OnFalling ,         // Action on transition - Falling edge
    *   cmpCallback,                 // Call-back to execute on event (if interrupts are enabled)
    *
    *   // Filter settings - must be in this order
    *   CmpFilterSamples_4 ,         // Filter Sample Count - 4 sample must agree
    *   100_ticks ,                  // Filter Sample Period in ticks or seconds (if support is enabled)
    *
    *   // DAC Settings - must be in this order
    *   CmpDacEnable_Enabled ,       // DAC Enable - Enabled
    *   CmpDacrefSel_Vdd ,           // DAC Reference Voltage Select - Vin2 (Vdd)
    *   31 ,                         // DAC level
    *
    *   // Inputs
    *   cmp0Input_D7.plusPin ,       // Plus Input Mux Control - D7
    *   Cmp0Input_D21::minusPin,     // Minus Input Mux Control - D21
    * };
    *
    * // Initialise Cmp0 from values specified above
    * Cmp0::configure(init)
    * @endcode
    */
   class Init {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      /// IRQ priority levels
      NvicPriority irqlevel = NvicPriority_Normal;

      ///  DAC Control Register
      uint8_t daccr = 0;

      ///  CMP Control Register 0
      uint8_t cr0 = 0;

      ///  CMP Control Register 1
      uint8_t cr1 = 0;

      ///  CMP Status and Control Register
      uint8_t scr = 0;

      ///  CMP Filter Period Register
      uint8_t fpr = 0;

      ///  CMP MUX Control Register
      uint8_t muxcr = 0;

      /**
       * Constructor for IRQ priority levels
       *
       * @tparam   Types
       * @param    rest
       *
       * @param nvicPriority Priority level used to configure the NVIC
       *        Subset of available levels
       */
      template <typename... Types>
      constexpr Init(NvicPriority nvicPriority, Types... rest) : Init(rest...) {
   
         irqlevel = nvicPriority;
      }

      /**
       * Constructor for Comparator Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmpEnable Enable comparator
       */
      template <typename... Types>
      constexpr Init(CmpEnable cmpEnable, Types... rest) : Init(rest...) {
   
         cr1 = (cr1&~CMP_CR1_EN_MASK) | cmpEnable;
      }
   
      /**
       * Constructor for Operating mode
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmpMode Selects operation in sampling or windowed mode
       */
      template <typename... Types>
      constexpr Init(CmpMode cmpMode, Types... rest) : Init(rest...) {
   
         cr1 = (cr1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK)) | cmpMode;
      }
   
      /**
       * Constructor for Trigger Mode Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmpTrigger CMP and DAC are configured to CMP Trigger mode.  
       *        CMP Trigger mode depends on an external timer resource to periodically enable 
       *        Upon setting TRIGM, the CMP and DAC are placed in a standby state until an 
       *        external timer resource trigger is received.
       */
      template <typename... Types>
      constexpr Init(CmpTrigger cmpTrigger, Types... rest) : Init(rest...) {
   
         cr1 = (cr1&~CMP_CR1_TRIGM_MASK) | cmpTrigger;
      }
   
      /**
       * Constructor for Power Mode Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmpPower Selects trade-off between speed and power consumption
       */
      template <typename... Types>
      constexpr Init(CmpPower cmpPower, Types... rest) : Init(rest...) {
   
         cr1 = (cr1&~CMP_CR1_PMODE_MASK) | cmpPower;
      }
   
      /**
       * Constructor for Comparator Invert
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmpPolarity Allows selection of the polarity of the analog comparator function
       */
      template <typename... Types>
      constexpr Init(CmpPolarity cmpPolarity, Types... rest) : Init(rest...) {
   
         cr1 = (cr1&~CMP_CR1_INV_MASK) | cmpPolarity;
      }
   
      /**
       * Constructor for Comparator output pin source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmpOutput Selects whether the output pin is driven by the filtered or unfiltered comparator output
       */
      template <typename... Types>
      constexpr Init(CmpOutput cmpOutput, Types... rest) : Init(rest...) {
   
         cr1 = (cr1&~(CMP_CR1_OPE_MASK|CMP_CR1_COS_MASK)) | cmpOutput;
      }
   
      /**
       * Constructor for Comparator hard block hysteresis control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmpHysteresis Defines the programmable hysteresis level.
       *        The hysteresis values associated with each level are device specific
       */
      template <typename... Types>
      constexpr Init(CmpHysteresis cmpHysteresis, Types... rest) : Init(rest...) {
   
         cr0 = (cr0&~CMP_CR0_HYSTCTR_MASK) | cmpHysteresis;
      }
   
      /**
       * Constructor for Action on transition
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmpEvent Enables interrupt request on comparator transition
       */
      template <typename... Types>
      constexpr Init(CmpEvent cmpEvent, Types... rest) : Init(rest...) {
   
         scr = (scr&~(CMP_SCR_IER_MASK|CMP_SCR_IEF_MASK)) | cmpEvent;
      }
   
      /**
       * Constructor for Plus Input Mux Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmp0InputPlus Determines which input is selected for the plus input of the comparator
       */
      template <typename... Types>
      constexpr Init(Cmp0InputPlus cmp0InputPlus, Types... rest) : Init(rest...) {
   
         muxcr = (muxcr&~CMP_MUXCR_PSEL_MASK) | cmp0InputPlus;
      }
   
      /**
       * Constructor for Minus Input Mux Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmp0InputMinus Determines which input is selected for the minus input of the comparator
       */
      template <typename... Types>
      constexpr Init(Cmp0InputMinus cmp0InputMinus, Types... rest) : Init(rest...) {
   
         muxcr = (muxcr&~CMP_MUXCR_MSEL_MASK) | cmp0InputMinus;
      }
   
      /**
       * Constructor for Filter Sample Count
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmpFilterSamples Represents the number of consecutive samples that must agree prior 
       *        to the comparator output filter accepting a new output state
       * @param ticks            Specifies the sampling period, in clock cycles, of the comparator output filter 
       *        This has no effect if SE=1. In that case, the external SAMPLE signal is used to 
       *        determine the sampling period.
       */
      template <typename... Types>
      constexpr Init(
            CmpFilterSamples cmpFilterSamples,
            Ticks            ticks, Types... rest) : Init(rest...) {
   
         cr0 = (cr0&~CMP_CR0_FILTER_CNT_MASK) | cmpFilterSamples;
         fpr = ticks;
      }
   
      /**
       * Constructor for DAC Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmpDacEnable Enables the internal DAC
       * @param cmpDacrefSel Supply Voltage Reference Source Select
       * @param value        Specifies the output level of the internal DAC
       */
      template <typename... Types>
      constexpr Init(
            CmpDacEnable cmpDacEnable,
            CmpDacrefSel cmpDacrefSel,
            uint8_t      value, Types... rest) : Init(rest...) {
   
         daccr = (daccr&~(CMP_DACCR_DACEN_MASK|CMP_DACCR_VRSEL_MASK)) | cmpDacEnable | cmpDacrefSel;
         daccr = (daccr&~CMP_DACCR_VOSEL_MASK) | CMP_DACCR_VOSEL(value);
      }
   
   };

};

class Cmp0Info {
public:
   /*
    * Template:cmp0_trigm
    */
   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = CMP0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_Normal;

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = CMP0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<CMP_Type> cmp = baseAddress;

   //! Pin number in Info table for comparator output if mapped to a pin
   static constexpr int outputPin  = 8;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /**
    * Class used to do initialisation of the Cmp0
    *
    * This class has a templated constructor that accepts various values.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Cmp0::Init init {
    *
    *   // General setup
    *   CmpEnable_Enabled ,          // Comparator Enable - Comparator is enabled
    *   CmpMode_Direct ,             // Operating mode - Direct
    *   CmpTrigger_Enabled ,         // Trigger Mode Enable - Trigger mode is enabled
    *   CmpPower_HighSpeed ,         // Power Mode Select - High-Speed Comparison mode
    *   CmpPolarity_Inverted ,       // Comparator Invert - Inverted
    *   CmpOutput_Direct ,           // Comparator output pin source - Direct (unfiltered)
    *   CmpHysteresis_Level_2 ,      // Comparator hard block hysteresis control - Level 2
    *   CmpDma_Disabled ,            // DMA Enable Control - Disabled
    *
    *   // Interrupt handling - must be in this order
    *   CmpEvent_OnFalling ,         // Action on transition - Falling edge
    *   cmpCallback,                 // Call-back to execute on event (if interrupts are enabled)
    *
    *   // Filter settings - must be in this order
    *   CmpFilterSamples_4 ,         // Filter Sample Count - 4 sample must agree
    *   100_ticks ,                  // Filter Sample Period in ticks or seconds (if support is enabled)
    *
    *   // DAC Settings - must be in this order
    *   CmpDacEnable_Enabled ,       // DAC Enable - Enabled
    *   CmpDacrefSel_Vdd ,           // DAC Reference Voltage Select - Vin2 (Vdd)
    *   31 ,                         // DAC level
    *
    *   // Inputs
    *   cmp0Input_D7.plusPin ,       // Plus Input Mux Control - D7
    *   Cmp0Input_D21::minusPin,     // Minus Input Mux Control - D21
    * };
    *
    * // Initialise Cmp0 from values specified above
    * Cmp0::configure(init)
    * @endcode
    */
   typedef Cmp0BasicInfo::Init Init;
   
   /**
    * Cmp0 interrupt call back
    */
   typedef Cmp0BasicInfo::CallbackFunction CallbackFunction;
   
   /**
    * Default initialisation value for Dac0
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr Init DefaultInitValue = {
      CmpEnable_Disabled , // Comparator Enable - Comparator is disabled
      CmpMode_Direct , // Operating mode - Direct
      CmpTrigger_Disabled , // Trigger Mode Enable - Trigger mode is disabled
      CmpPower_LowSpeed , // Power Mode Select - Low-Speed Comparison mode
      CmpPolarity_Normal , // Comparator Invert - Not inverted
      CmpOutput_Disabled , // Comparator output pin source - Disabled
      CmpHysteresis_Level_0 , // Comparator hard block hysteresis control - Level 0
      CmpEvent_Disabled , // Action on transition - Disabled
      CmpFilterSamples_Bypassed , // Filter Sample Count - Disabled
      0_ticks , // Filter Sample Period in ticks
      CmpDacEnable_Disabled , // DAC Enable - Disabled
      CmpDacrefSel_VrefOut , // DAC Reference Voltage Select - Vin1 (Vref_OUT)
      31 , // DAC level
      Cmp0InputPlus_0 , // Plus Input Mux Control - CMP_IN0
      Cmp0InputMinus_0,  // Minus Input Mux Control - CMP_IN0
   };

   /**
    * Get clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static __attribute__((always_inline)) uint32_t getClockFrequency() {
      return SystemBusClock;
   }

   /**
    * Configure Comparator input sources
    *
    * @param cmp0InputPlus  Determines which input is selected for the plus input of the comparator
    * @param cmp0InputMinus Determines which input is selected for the minus input of the comparator
    */
   static void selectInputs(
         Cmp0InputPlus  cmp0InputPlus,
         Cmp0InputMinus cmp0InputMinus) {
   
      //! MUX Control Register
      cmp->MUXCR = cmp0InputPlus|cmp0InputMinus;
   }
   
      /**
       * Class representing a Comparator pin
       *
       * @tparam cmpInput Number of comparator input (0-7) for associated pin.
       */
      template<Cmp0InputMinus cmpInput>
      class Pin {
         using Pcr = PcrTable_T<Cmp0Info,cmpInput>;
   
      public:
         static constexpr Cmp0InputPlus  plusPin  = (Cmp0InputPlus)CMP_MUXCR_PSEL(cmpInput);
         static constexpr Cmp0InputMinus minusPin = cmpInput;
   
         constexpr operator Cmp0InputPlus()  const { return plusPin;  }
         constexpr operator Cmp0InputMinus() const { return minusPin; }
   
         constexpr Pin() {}
   
         static void setInput() {
            Pcr::setPCR();
         }
      };
   
   /** 
    *  Enable clock to Cmp0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableCmp0Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_CMP0_MASK;
#endif
   }

   /** 
    *  Disable clock to Cmp0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableCmp0Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_CMP0_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: CMP0_IN0             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: CMP0_IN1             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: CMP0_IN2             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: CMP0_IN3             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   5: CMP0_IN5             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   6: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   7: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   8: CMP0_OUT             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group CMP_Group
 * @}
 */
/**
 * @addtogroup Control_Group CONTROL, Control
 * @brief Abstraction for Control
 * @{
 */
/**
 * Peripheral information for CONTROL, Control.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class ControlInfo {
public:
   /*
    * Template:control
    */
using SWD_CLK_pin          = PcrTable_T<ControlInfo,0>;
using RESET_b_pin          = PcrTable_T<ControlInfo,1>;
using SWD_DIO_pin          = PcrTable_T<ControlInfo,2>;

   //! Number of signals available in info table
   static constexpr int numSignals  = 6;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: SWD_CLK              = PTA0(p14)                      */  { PortAInfo,  0,            (PcrValue)0x00300UL  },
         /*   1: RESET_b              = PTA1(p15)                      */  { PortAInfo,  1,            (PcrValue)0x00300UL  },
         /*   2: SWD_DIO              = PTA2(p16)                      */  { PortAInfo,  2,            (PcrValue)0x00300UL  },
         /*   3: CLKOUT               = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: NMI_b                = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   5: CLKOUT32K            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCLR = 0x0300UL|PORT_GPCLR_GPWE(0x0007UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0007UL);
   }

};

/** 
 * End group Control_Group
 * @}
 */
/**
 * @addtogroup CONSOLE_Group Console, Console Interface
 * @brief Abstraction for Console Interface
 * @{
 */
/** 
 * End group CONSOLE_Group
 * @}
 */
/**
 * @addtogroup EXTERNALTRIGGER_Group ExternalTrigger, Shared Resources
 * @brief Abstraction for Shared Resources
 * @{
 */
/**
 * Peripheral information for ExternalTrigger, Shared Resources.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class ExternaltriggerInfo {
public:
   /*
    * Template:externaltrigger
    */
   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: EXTRG_IN             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group EXTERNALTRIGGER_Group
 * @}
 */
/**
 * @addtogroup FTFA_Group FTFA, Flash Memory Module
 * @brief Abstraction for Flash Memory Module
 * @{
 */
/**
 * Peripheral information for FTFA, Flash Memory Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class FtfaInfo {
public:
   /*
    * Template:ftfa
    */
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = FTFA_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<FTFA_Type> ftfa = baseAddress;

   /* Template_irqOptionSubstituted.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = FTFA_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /** 
    *  Enable clock to Ftfa
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableFtfaClock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_FTF_MASK;
#endif
   }

   /** 
    *  Disable clock to Ftfa
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableFtfaClock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_FTF_MASK;
#endif
   }

};

/** 
 * End group FTFA_Group
 * @}
 */
/**
 * @addtogroup I2C_Group I2C, Inter-Integrated-Circuit Interface
 * @brief Abstraction for Inter-Integrated-Circuit Interface
 * @{
 */
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class I2c0Info {
public:
   /*
    * Template:i2c0_mkl03
    */
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = I2C0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<I2C_Type> i2c = baseAddress;

   //! Pin number in Info table for SCL if mapped to a pin
   static constexpr int sclPin  = 0;

   //! Pin number in Info table for SDA if mapped to a pin
   static constexpr int sdaPin  = 1;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = I2C0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_Normal;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   /** 
    *  Enable clock to I2c0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableI2c0Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_I2C0_MASK;
#endif
   }

   /** 
    *  Disable clock to I2c0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableI2c0Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_I2C0_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: I2C0_SCL             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: I2C0_SDA             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group I2C_Group
 * @}
 */
/**
 * @addtogroup LLWU_Group LLWU, Low-leakage Wake-up Unit
 * @brief Abstraction for Low-leakage Wake-up Unit
 * @{
 */
/**
 * Peripheral information for LLWU, Low-leakage Wake-up Unit.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Wake-up pin control
    *
    * Enables and configures the edge detection for a wake-up pin
    */
   enum LlwuPinMode {
      LlwuPinMode_Disabled    = LLWU_PE1_WUPE0(0)|LLWU_PE1_WUPE1(0)|LLWU_PE1_WUPE2(0)|LLWU_PE1_WUPE3(0), ///< Wake-up pin disabled
      LlwuPinMode_RisingEdge  = LLWU_PE1_WUPE0(1)|LLWU_PE1_WUPE1(1)|LLWU_PE1_WUPE2(1)|LLWU_PE1_WUPE3(1), ///< Wake-up on pin rising edge
      LlwuPinMode_FallingEdge = LLWU_PE1_WUPE0(2)|LLWU_PE1_WUPE1(2)|LLWU_PE1_WUPE2(2)|LLWU_PE1_WUPE3(2), ///< Wake-up on pin falling edge
      LlwuPinMode_EitherEdge  = LLWU_PE1_WUPE0(3)|LLWU_PE1_WUPE1(3)|LLWU_PE1_WUPE2(3)|LLWU_PE1_WUPE3(3), ///< Wake-up on pin either edge

   };

   /**
    * Wake-up On External Pin with Digital Filter
    *
    * Controls the digital filter options for the external pin detect
    */
   enum LlwuFilterPinMode {
      LlwuFilterPinMode_Disabled    = LLWU_FILT_FILTE(0), ///< Wake-up disabled
      LlwuFilterPinMode_RisingEdge  = LLWU_FILT_FILTE(1), ///< Wake-up on filtered rising edge
      LlwuFilterPinMode_FallingEdge = LLWU_FILT_FILTE(2), ///< Wake-up on filtered falling edge
      LlwuFilterPinMode_EitherEdge  = LLWU_FILT_FILTE(3), ///< Wake-up on either filtered edge

   };

   /**
    * Pin filter numbers
    *
    * @note These are used as an index into the FILT table so numbers do NOT correspond to filter names FILT[0] <=> FILT1 etc
    */
   enum LlwuFilterNum {
      LlwuFilterNum_1 = 0,  //!<  Wake-up pin LLWU_P1
   };

   enum LlwuPin : uint32_t {
      LlwuPin_0 = 0,  //!<  Wake-up pin LLWU_P0
      LlwuPin_1 = 1,  //!<  Wake-up pin LLWU_P1
      LlwuPin_2 = 2,  //!<  Wake-up pin LLWU_P2
      LlwuPin_3 = 3,  //!<  Wake-up pin LLWU_P3
      LlwuPin_4 = 4,  //!<  Wake-up pin LLWU_P4
      LlwuPin_5 = 5,  //!<  Wake-up pin LLWU_P5
      LlwuPin_6 = 6,  //!<  Wake-up pin LLWU_P6
      LlwuPin_7 = 7,  //!<  Wake-up pin LLWU_P7
      LlwuPin_Ptb0         = LlwuPin_4,    ///< Mapped pin PTB0(p8)

   };

class LlwuInfo {
public:
   /*
    * Template:llwu_pe2_filt1
    */
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LLWU_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<LLWU_Type> llwu = baseAddress;

   /**
    * Class used to do initialisation of LLWU
    *
    * This class has a templated constructor that accepts various values:
    * - llwuPeripheral,                            - Peripheral to enable as wake-up source
    * - llwuPin, llwuPinMode,                      - Pin to enable as direct wake-up source
    * - llwuFilterNum, llwuPin, llwuFilterPinMode, - Pin to enable as filtered wake-up source
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * const Llwu::Init llwuInit {
    *    // Pins
    *    LlwuPin_Pta4,  LlwuPinMode_FallingEdge,
    *    LlwuPin_Pta13, LlwuPinMode_EitherEdge,
    *    LlwuPin_Ptd4,  LlwuPinMode_RisingEdge,
    *
    *    // Filtered Pins
    *    LlwuFilterNum_1, LlwuPin_Pta4, LlwuFilterPinMode_EitherEdge,
    *    LlwuFilterNum_2, LlwuPin_Ptc3, LlwuFilterPinMode_RisingEdge,
    *
    *    // Peripherals
    *    LlwuPeripheral_RtcAlarm,
    *    LlwuPeripheral_Lptmr0,
    *
    *    // Reset
    *    LlwuResetWakeup_Enabled, LlwuResetFilter_Enabled
    * };
    *
    * // Initialise LLWU from values specified above
    * llwuInit.configure()
    * @endcode
    */
   class Init {
   
   public:
      /**
       * Constructor
       */
      constexpr Init() {
      }
              
   private:
      static constexpr uint8_t masks[] =
         {LLWU_PE1_WUPE0_MASK, LLWU_PE1_WUPE1_MASK, LLWU_PE1_WUPE2_MASK, LLWU_PE1_WUPE3_MASK, };
   
      uint8_t pe[2]   = {0};
      uint8_t filt[1] = {0};
   
   public:
      /**
       * Constructor for filtered pin source
       *
       * @tparam Types
       * @param rest
       *
       * @param llwuFilterNum       Filter to use
       * @param llwuPin             Peripheral to enable as wake-up source
       * @param llwuFilterPinMode   Sensitivity of pin
       */
      template <typename... Types>
      constexpr Init(
            LlwuFilterNum     llwuFilterNum,
            LlwuPin           llwuPin,
            LlwuFilterPinMode llwuFilterPinMode,
            Types... rest) : Init(rest...) {
      
         // LLWU_FILT_FILTF_MASK clears flag on write to register   
         filt[llwuFilterNum] = LLWU_FILT_FILTF_MASK|llwuFilterPinMode|llwuPin;
      }
   
      /**
       * Constructor for unfiltered pin source
       *
       * @tparam Types
       * @param rest
       *
       * @param llwuPin       Peripheral to enable as wake-up source
       * @param llwuPinMode   Sensitivity of pin
       */
      template <typename... Types>
      constexpr Init(LlwuPin llwuPin, LlwuPinMode llwuPinMode, Types... rest) : Init(rest...) {
      
         const int      index = llwuPin>>2;
         const uint8_t  value = llwuPinMode & masks[llwuPin&3];
      
         pe[index] |= value;
      }
   
      /**
       * Configure LLWU from values specified in constructor.
       * LLWU flags from pin events are cleared.
       * Requests from peripheral devices must be cleared at source
       */
      void configure() const {
         // Clear pin flags
         llwu->PF1  = 0xFF;
         // Configure pin source
         llwu->PE1  = pe[0];
         // Configure pin source
         llwu->PE2  = pe[1];
         // Configure and clear filtered pin source
         llwu->FILT1 = filt[0];
      }
   };

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = LLWU_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_Normal;

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   1: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   2: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   3: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   4: LLWU_P4              = PTB0(p8)                       */  { PortBInfo,  0,            (PcrValue)0x00100UL  },
         /*   5: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   6: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   7: LLWU_P7              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTB_CLOCK_MASK);
#endif

   PORTB->GPCLR = 0x0100UL|PORT_GPCLR_GPWE(0x0001UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTB_CLOCK_MASK);
#endif

   PORTB->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0001UL);
   }

};

/** 
 * End group LLWU_Group
 * @}
 */
/**
 * @addtogroup LPTMR_Group LPTMR, Low Power Timer
 * @brief Abstraction for Low Power Timer
 * @{
 */
/**
 * Peripheral information for LPTMR, Low Power Timer.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Timer interrupt enable
    *
    * Enables LPTMR interrupts
    */
   enum LptmrInterrupt {
      LptmrInterrupt_Disabled = LPTMR_CSR_TIE(0), ///< Interrupt disabled
      LptmrInterrupt_Enabled  = LPTMR_CSR_TIE(1), ///< Interrupt enabled

   };

   /**
    * Counter Action on Compare Event
    *
    * Counter action when lptmr_csr_tcf is set
    */
   enum LptmrResetOnCompare {
      LptmrResetOnCompare_Enabled  = LPTMR_CSR_TFC(0), ///< lptmr_cnr is reset whenever lptmr_csr_tcf is set
      LptmrResetOnCompare_Disabled = LPTMR_CSR_TFC(1), ///< lptmr_cnr is reset on overflow only

   };

   /**
    * Timer Mode Select
    *
    * Configures the mode of the LPTMR
    */
   enum LptmrMode {
      LptmrMode_TimeInterval  = LPTMR_CSR_TMS(0), ///< Time Interval mode
      LptmrMode_PulseCounting = LPTMR_CSR_TMS(1), ///< Pulse Counter mode

   };

   /**
    * Clock Source
    *
    * Clock source for LPTMR
    */
   enum LptmrClockSel {
      LptmrClockSel_Mcgirclk = LPTMR_PSR_PCS(0), ///< MCG Internal Reference Clock (MCGIRCLK)
      LptmrClockSel_Lpoclk   = LPTMR_PSR_PCS(1), ///< Low power oscillator (LPO - 1kHz)
      LptmrClockSel_Erclk32  = LPTMR_PSR_PCS(2), ///< 32kHz Clock Source (ERCLK32)
      LptmrClockSel_Oscerclk = LPTMR_PSR_PCS(3), ///< Oscillator External Reference Clock (OSCERCLK)

   };

   /**
    * Prescaler Value
    *
    * Configures the size of the Prescaler in Time Interval mode
    */
   enum LptmrPrescale {
      LptmrPrescale_Direct      = LPTMR_PSR_PBYP(1)|LPTMR_PSR_PRESCALE(0),  ///< Prescaler = 1
      LptmrPrescale_DivBy_2     = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(0),  ///< Prescaler = 2
      LptmrPrescale_DivBy_4     = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(1),  ///< Prescaler = 4
      LptmrPrescale_DivBy_8     = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(2),  ///< Prescaler = 8
      LptmrPrescale_DivBy_16    = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(3),  ///< Prescaler = 16,
      LptmrPrescale_DivBy_32    = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(4),  ///< Prescaler = 32,
      LptmrPrescale_DivBy_64    = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(5),  ///< Prescaler = 64
      LptmrPrescale_DivBy_128   = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(6),  ///< Prescaler = 128
      LptmrPrescale_DivBy_256   = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(7),  ///< Prescaler = 256
      LptmrPrescale_DivBy_512   = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(8),  ///< Prescaler = 512
      LptmrPrescale_DivBy_1024  = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(9),  ///< Prescaler = 1024
      LptmrPrescale_DivBy_2048  = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(10), ///< Prescaler = 2048
      LptmrPrescale_DivBy_4096  = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(11), ///< Prescaler = 4096
      LptmrPrescale_DivBy_8192  = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(12), ///< Prescaler = 8192
      LptmrPrescale_DivBy_16384 = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(13), ///< Prescaler = 16384
      LptmrPrescale_DivBy_32768 = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(14), ///< Prescaler = 32768
      LptmrPrescale_DivBy_65536 = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(15), ///< Prescaler = 65536

   };

   /**
    * Filter Value
    *
    * Configures the size of the glitch filter in Pulse Counting mode
    */
   enum LptmrGlitchFilter {
      LptmrGlitchFilter_Direct       = LPTMR_PSR_PBYP(1)|LPTMR_PSR_PRESCALE(0),  ///< No glitch filter
      LptmrGlitchFilter_2_clocks     = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(1),  ///< 2 clock cycle glitch filter
      LptmrGlitchFilter_4_clocks     = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(2),  ///< 4 clock cycle glitch filter
      LptmrGlitchFilter_8_clocks     = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(3),  ///< 8 clock cycle glitch filter
      LptmrGlitchFilter_16_clocks    = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(4),  ///< 16 clock cycle glitch filter
      LptmrGlitchFilter_32_clocks    = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(5),  ///< 32 clock cycle glitch filter
      LptmrGlitchFilter_64_clocks    = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(6),  ///< 64 clock cycle glitch filter
      LptmrGlitchFilter_128_clocks   = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(7),  ///< 128 clock cycle glitch filter
      LptmrGlitchFilter_256_clocks   = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(8),  ///< 256 clock cycle glitch filter
      LptmrGlitchFilter_512_clocks   = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(9),  ///< 512 clock cycle glitch filter
      LptmrGlitchFilter_1024_clocks  = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(10), ///< 1024 clock cycle glitch filter
      LptmrGlitchFilter_2048_clocks  = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(11), ///< 2048 clock cycle glitch filter
      LptmrGlitchFilter_4096_clocks  = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(12), ///< 4096 clock cycle glitch filter
      LptmrGlitchFilter_81924_clocks = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(13), ///< 8192 clock cycle glitch filter
      LptmrGlitchFilter_16384_clocks = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(14), ///< 16384 clock cycle glitch filter
      LptmrGlitchFilter_32768_clocks = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(15), ///< 32768 clock cycle glitch filter

   };

   /**
    * Input Pin
    *
    * Input source to be used in Pulse Counter mode
    */
   enum LptmrPinSel {
      LptmrPinSel_Cmp0    = LPTMR_CSR_TPS(0), ///< CMP0 output
      LptmrPinSel_AltPin1 = LPTMR_CSR_TPS(1), ///< LPTMR_ALT1 pin
      LptmrPinSel_AltPin2 = LPTMR_CSR_TPS(2), ///< LPTMR_ALT2 pin

   };

   /**
    * Pin Polarity
    *
    * Polarity of the input source in Pulse Counter mode
    */
   enum LptmrPulseEdge {
      LptmrPulseEdge_Rising  = LPTMR_CSR_TPP(0), ///< Active-high source, rising-edge increments lptmr_cnr
      LptmrPulseEdge_Falling = LPTMR_CSR_TPP(1), ///< Active-low source,  falling-edge increments lptmr_cnr

   };

class Lptmr0Info {
public:
   /*
    * Template:lptmr0
    */
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LPTMR0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<LPTMR_Type> lptmr = baseAddress;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /* Template_irqOptionSubstituted.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = LPTMR0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   
   /// Minimum resolution for time interval setting
   static constexpr uint32_t minimumResolution = 100;

   /**
    * Set Timer Compare Register
    *
    * @param ticks   Comparison value
    *        The timer comparison flag is set when the counter reaches this value and increments. 
    *        The hardware trigger will assert until the next time the counter increments. 
    *        This value determines the period in TimeInterval mode or the event time in Pulse Counting mode
    */
   static void setCompareThreshold(Ticks   ticks) {
      lptmr->CMR = ticks;
   }

   /**
    * Set Counter Action on Compare Event
    *
    * @param lptmrResetOnCompare Counter action when lptmr_csr_tcf is set
    */
   static void setActionOnCompare(LptmrResetOnCompare lptmrResetOnCompare) {
      lptmr->CSR = (lptmr->CSR&~LPTMR_CSR_TFC_MASK) | lptmrResetOnCompare;
   }

   /**
    * Set Input Pin and Pin Polarity
    *
    * @param lptmrPinSel    Input source to be used in Pulse Counter mode
    * @param lptmrPulseEdge Polarity of the input source in Pulse Counter mode
    */
   static void selectPulseInput(
         LptmrPinSel    lptmrPinSel,
         LptmrPulseEdge lptmrPulseEdge = LptmrPulseEdge_Rising) {
      lptmr->CSR = (lptmr->CSR&~(LPTMR_CSR_TPS_MASK|LPTMR_CSR_TPP_MASK)) | lptmrPinSel|lptmrPulseEdge;
   }

   /**
    * Set Timer interrupt enable
    *
    * @param lptmrInterrupt Enables LPTMR interrupts
    */
   static void enableInterrupts(LptmrInterrupt lptmrInterrupt) {
   
      if(lptmrInterrupt) {
         lptmr->CSR = lptmr->CSR | LPTMR_CSR_TIE_MASK;
      }
      else {
         lptmr->CSR = lptmr->CSR & ~LPTMR_CSR_TIE_MASK;
      }
   }
   /**
    * Clear interrupt flag
    */
   static void clearInterruptFlag() {
   
      lptmr->CSR = lptmr->CSR | LPTMR_CSR_TCF_MASK;
   }

   /**
    * Set Clock Source and Prescaler Value
    *
    * These settings are used for the clock prescaler in timer mode.
    *
    * @param lptmrClockSel Clock source for LPTMR
    * @param lptmrPrescale Configures the size of the Prescaler in Time Interval mode
    */
   static void setClock(
         LptmrClockSel lptmrClockSel,
         LptmrPrescale lptmrPrescale = LptmrPrescale_Direct) {
      // Disable LPTMR before prescale change
      uint32_t csr = lptmr->CSR;
      lptmr->CSR   = 0;
      (void)(lptmr->CSR);
      lptmr->PSR   = lptmrClockSel|lptmrPrescale;
      lptmr->CSR   = csr;
   }

   /**
    * Set Clock Source and Filter Value
    *
    * These settings are used for the glitch filter in pulse-counting mode.
    *
    * @param lptmrClockSel     Clock source for LPTMR
    * @param lptmrGlitchFilter Configures the size of the glitch filter in Pulse Counting mode
    */
   static void setClock(
         LptmrClockSel     lptmrClockSel,
         LptmrGlitchFilter lptmrGlitchFilter = LptmrGlitchFilter_Direct) {
      // Disable LPTMR before prescale change
      uint32_t csr = lptmr->CSR;
      lptmr->CSR   = 0;
      (void)(lptmr->CSR);
      lptmr->PSR   = lptmrClockSel|lptmrGlitchFilter;
      lptmr->CSR   = csr;
   }

   /**
    * Set Clock Source
    *
    * @param lptmrClockSel Clock source for LPTMR
    */
   static void setInputClockSource(LptmrClockSel lptmrClockSel) {
      lptmr->PSR = (lptmr->PSR&~LPTMR_PSR_PCS_MASK) | lptmrClockSel;
   }
   
   /**
    * Get Clock Source frequency
    *
    * @param lptmrClockSel Clock source for LPTMR
   
    * @return Clock frequency in Hz
    */
   static uint32_t getInputClockFrequency(LptmrClockSel lptmrClockSel) {
   
      switch(lptmrClockSel) {
         default:
         case LptmrClockSel_Mcgirclk : return McgInfo::getMcgIrClock();  ///< MCG Internal Reference Clock (MCGIRCLK)
         case LptmrClockSel_Lpoclk   : return PmcInfo::getLpoClock();    ///< Low power oscillator (LPO - 1kHz)
         case LptmrClockSel_Erclk32  : return SimInfo::getErc32kClock(); ///< 32kHz Clock Source (ERCLK32)
         case LptmrClockSel_Oscerclk : return Osc0Info::getOscerClock(); ///< Oscillator External Reference Clock (OSCERCLK)

      }
   }
   
   /**
    * Get Clock Source frequency
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      return getInputClockFrequency((LptmrClockSel)(lptmr->PSR&LPTMR_PSR_PCS_MASK));
   }
   
   /**
    * Get clock frequency after prescaler
    *
    * @return Frequency as a float in Hz
    */
   static float getClockFrequencyF() {
   
      float freq = getInputClockFrequency();
      if (lptmr->PSR&LPTMR_PSR_PBYP_MASK) {
         return freq;
      }
      return freq/(1<<(((lptmr->PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
   }
   
   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getClockFrequency() {
   
      uint32_t freq = getInputClockFrequency();
      if (lptmr->PSR&LPTMR_PSR_PBYP_MASK) {
         return freq;
      }
      return freq/(1<<(((lptmr->PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
   }

   /// Type for Peripheral interrupt handling
   typedef void (*CallbackFunction)();

   /**
    * Class used to do initialisation of LPTMR
    */
   class Init {
   
   protected:
      /**
       * No Copy Constructor
       */
      constexpr Init(const Init &other) = delete;
   
      /**
       * No Default Constructor
       */
      constexpr Init() = delete;
   
      /**
       * Usual Constructor
       */
      constexpr Init(LptmrMode lptmrMode) : csr(lptmrMode|LPTMR_CSR_TEN_MASK) {
      }

   
   public:   
#if false
      /// Peripheral interrupt handling
      CallbackFunction callbackFunction = nullptr;
#endif

      /// Timer Compare Interval
      Seconds cmrperiod = 0_s;

      /// Timer Compare Register
      Ticks cmr = 0_ticks;

      /// Prescale Register
      uint8_t psr = 0;

      /// IRQ priority levels
      NvicPriority irqlevel = NvicPriority_Normal;

      /// Control and Status Register
      uint8_t csr;

   };

   /**
    * Class used to do initialisation of LPTMR in Time Interval Mode
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Lptmr0::TimeIntervalModeInit lptmrInit {
    *    LptmrResetOn_Compare,    // Timer Free-Running Counter enable
    *    LptmrInterrupt_Disabled, // Timer interrupt enable
    *    LptmrClockSel_Oscerclk,  // Clock Source
    *    LptmrPrescale_Direct,    // Prescaler Value
    *    100_ms,                  // Timer Compare Register
    * };
    *
    * // Initialise LPTMR0 in Time Interval mode using values specified above
    * Lptmr0.configure(lptmrInit)
    * @endcode
    */
   class TimeIntervalModeInit : public Init {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr TimeIntervalModeInit(const TimeIntervalModeInit &other) = delete;
   
      /**
       * Default Constructor
       */
      constexpr TimeIntervalModeInit() : Init(LptmrMode_TimeInterval) {
      };
   
#if false
      /**
       * Constructor for Peripheral interrupt handling
       *
       * @tparam   Types
       * @param    rest
       *
       * @param callbackFunction If enabled, the handler may be set using the setCallback() function or
       *        by overriding the interrupt handler method in the peripheral class
       *        If not enabled, then interrupt handlers may be installed by naming them 
       *        (see weak names used in vector table).
       */
      template <typename... Types>
      constexpr TimeIntervalModeInit(CallbackFunction callbackFunction, Types... rest) : TimeIntervalModeInit(rest...) {
   
         this->callbackFunction = callbackFunction;
      }
#endif

      /**
       * Constructor for IRQ priority levels
       *
       * @tparam   Types
       * @param    rest
       *
       * @param nvicPriority Priority level used to configure the NVIC
       *        Subset of available levels
       */
      template <typename... Types>
      constexpr TimeIntervalModeInit(NvicPriority nvicPriority, Types... rest) : TimeIntervalModeInit(rest...) {
   
         irqlevel = nvicPriority;
      }

      /**
       * Constructor for Timer interrupt enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param lptmrInterrupt Enables LPTMR interrupts
       */
      template <typename... Types>
      constexpr TimeIntervalModeInit(LptmrInterrupt lptmrInterrupt, Types... rest) : TimeIntervalModeInit(rest...) {
   
         csr = (csr & ~LPTMR_CSR_TIE_MASK) | lptmrInterrupt;
      }

      /**
       * Constructor for Counter Action on Compare Event
       *
       * @tparam   Types
       * @param    rest
       *
       * @param lptmrResetOnCompare Counter action when lptmr_csr_tcf is set
       */
      template <typename... Types>
      constexpr TimeIntervalModeInit(LptmrResetOnCompare lptmrResetOnCompare, Types... rest) : TimeIntervalModeInit(rest...) {
   
         csr = (csr & ~LPTMR_CSR_TFC_MASK) | lptmrResetOnCompare;
      }

      /**
       * Constructor for Prescaler Value
       *
       * @tparam   Types
       * @param    rest
       *
       * @param lptmrPrescale Configures the size of the Prescaler in Time Interval mode
       */
      template <typename... Types>
      constexpr TimeIntervalModeInit(LptmrPrescale lptmrPrescale, Types... rest) : TimeIntervalModeInit(rest...) {
   
         psr = (psr & ~(LPTMR_PSR_PBYP_MASK|LPTMR_PSR_PRESCALE_MASK)) | lptmrPrescale;
      }

      /**
       * Constructor for Clock Source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param lptmrClockSel Clock source for LPTMR
       */
      template <typename... Types>
      constexpr TimeIntervalModeInit(LptmrClockSel lptmrClockSel, Types... rest) : TimeIntervalModeInit(rest...) {
   
         psr = (psr & ~LPTMR_PSR_PCS_MASK) | lptmrClockSel;
      }

      /**
       * Constructor for Timer Compare Register
       *
       * @param ticks   Comparison value
       *        The timer comparison flag is set when the counter reaches this value and increments. 
       *        The hardware trigger will assert until the next time the counter increments. 
       *        This value determines the period in TimeInterval mode or the event time in Pulse Counting mode
       */
      constexpr TimeIntervalModeInit(Ticks&  ticks) : Init(LptmrMode_TimeInterval) {
   
         cmr = ticks;
      }

      /**
       * Constructor for Timer Compare Interval
       *
       * @param seconds   Comparison value
       *        The timer comparison flag is set when the counter reaches this value and increments. 
       *        The hardware trigger will assert until the next time the counter increments. 
       *        This value determines the period in TimeInterval mode or the event time in Pulse Counting mode
       */
      constexpr TimeIntervalModeInit(Seconds&  seconds) : Init(LptmrMode_TimeInterval) {
   
         cmrperiod = seconds;
      }

   };

   /**
    * Class used to do initialisation of LPTMR in Pulse Counting Mode
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Lptmr0::PulseCountingModeInit lptmrInit {
    *    LptmrPinSel_Cmp0,           // Timer Pin Select for Pulse Counter mode
    *    LptmrPulseEdge_Rising,      // Timer Pin Polarity for Pulse Counter mode
    *    LptmrClockSel_Oscerclk,     // Clock Source
    *    LptmrGlitchFilter_Direct,   // Filter Value
    *    LptmrInterrupt_Disabled,    // Timer interrupt enable
    *    LptmrResetOn_Compare,       // Timer Free-Running Counter enable
    *    916_ticks,                  // Timer Compare Register
    * };
    *
    * // Initialise LPTMR0 in Pulse Counting mode using values specified above
    * Lptmr0.configure(lptmrInit)
    * @endcode
    */
   class PulseCountingModeInit : public Init {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr PulseCountingModeInit(const PulseCountingModeInit &other) = delete;
   
      /**
       * Default Constructor
       */
      constexpr PulseCountingModeInit() : Init(LptmrMode_PulseCounting) {
      }
   
#if false
      /**
       * Constructor for Peripheral interrupt handling
       *
       * @tparam   Types
       * @param    rest
       *
       * @param callbackFunction If enabled, the handler may be set using the setCallback() function or
       *        by overriding the interrupt handler method in the peripheral class
       *        If not enabled, then interrupt handlers may be installed by naming them 
       *        (see weak names used in vector table).
       */
      template <typename... Types>
      constexpr PulseCountingModeInit(CallbackFunction callbackFunction, Types... rest) : PulseCountingModeInit(rest...) {
   
         this->callbackFunction = callbackFunction;
      }
#endif

      /**
       * Constructor for IRQ priority levels
       *
       * @tparam   Types
       * @param    rest
       *
       * @param nvicPriority Priority level used to configure the NVIC
       *        Subset of available levels
       */
      template <typename... Types>
      constexpr PulseCountingModeInit(NvicPriority nvicPriority, Types... rest) : PulseCountingModeInit(rest...) {
   
         irqlevel = nvicPriority;
      }

      /**
       * Constructor for Timer interrupt enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param lptmrInterrupt Enables LPTMR interrupts
       */
      template <typename... Types>
      constexpr PulseCountingModeInit(LptmrInterrupt lptmrInterrupt, Types... rest) : PulseCountingModeInit(rest...) {
   
         csr = (csr & ~LPTMR_CSR_TIE_MASK) | lptmrInterrupt;
      }

      /**
       * Constructor for Input Pin
       *
       * @tparam   Types
       * @param    rest
       *
       * @param lptmrPinSel Input source to be used in Pulse Counter mode
       */
      template <typename... Types>
      constexpr PulseCountingModeInit(LptmrPinSel lptmrPinSel, Types... rest) : PulseCountingModeInit(rest...) {
   
         csr = (csr & ~LPTMR_CSR_TPS_MASK) | lptmrPinSel;
      }

      /**
       * Constructor for Pin Polarity
       *
       * @tparam   Types
       * @param    rest
       *
       * @param lptmrPulseEdge Polarity of the input source in Pulse Counter mode
       */
      template <typename... Types>
      constexpr PulseCountingModeInit(LptmrPulseEdge lptmrPulseEdge, Types... rest) : PulseCountingModeInit(rest...) {
   
         csr = (csr & ~LPTMR_CSR_TPP_MASK) | lptmrPulseEdge;
      }

      /**
       * Constructor for Counter Action on Compare Event
       *
       * @tparam   Types
       * @param    rest
       *
       * @param lptmrResetOnCompare Counter action when lptmr_csr_tcf is set
       */
      template <typename... Types>
      constexpr PulseCountingModeInit(LptmrResetOnCompare lptmrResetOnCompare, Types... rest) : PulseCountingModeInit(rest...) {
   
         csr = (csr & ~LPTMR_CSR_TFC_MASK) | lptmrResetOnCompare;
      }

      /**
       * Constructor for Clock Source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param lptmrClockSel Clock source for LPTMR
       */
      template <typename... Types>
      constexpr PulseCountingModeInit(LptmrClockSel lptmrClockSel, Types... rest) : PulseCountingModeInit(rest...) {
   
         psr = (psr & ~LPTMR_PSR_PCS_MASK) | lptmrClockSel;
      }

      /**
       * Constructor for Filter Value
       *
       * @tparam   Types
       * @param    rest
       *
       * @param lptmrGlitchFilter Configures the size of the glitch filter in Pulse Counting mode
       */
      template <typename... Types>
      constexpr PulseCountingModeInit(LptmrGlitchFilter lptmrGlitchFilter, Types... rest) : PulseCountingModeInit(rest...) {
   
         psr = (psr & ~(LPTMR_PSR_PBYP_MASK|LPTMR_PSR_PRESCALE_MASK)) | lptmrGlitchFilter;
      }

      /**
       * Constructor for Timer Compare Register
       *
       * @param ticks   Comparison value
       *        The timer comparison flag is set when the counter reaches this value and increments. 
       *        The hardware trigger will assert until the next time the counter increments. 
       *        This value determines the period in TimeInterval mode or the event time in Pulse Counting mode
       */
      constexpr PulseCountingModeInit(Ticks&  ticks) : Init(LptmrMode_PulseCounting) {
   
         cmr = ticks;
      }

   };

   /** 
    *  Enable clock to Lptmr0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableLptmr0Clock();
#else
      SIM->SCGC5 = SIM->SCGC5 | SIM_SCGC5_LPTMR_MASK;
#endif
   }

   /** 
    *  Disable clock to Lptmr0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableLptmr0Clock();
#else
      SIM->SCGC5 = SIM->SCGC5 & ~SIM_SCGC5_LPTMR_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   1: LPTMR0_ALT1          = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: LPTMR0_ALT2          = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: LPTMR0_ALT3          = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group LPTMR_Group
 * @}
 */
/**
 * @addtogroup LPUART_Group LPUART, Low Power Universal Asynchronous Receiver/Transmitter
 * @brief Abstraction for Low Power Universal Asynchronous Receiver/Transmitter
 * @{
 */
/**
 * Peripheral information for LPUART, Low Power Universal Asynchronous Receiver/Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Lpuart0Info {
public:
   /*
    * Template:lpuart0_mkl03
    */
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LPUART0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<LPUART_Type> lpuart = baseAddress;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   //! Number of samples per bit
   static constexpr uint32_t oversampleRatio = 8;

   /* Template_irqOptionSubstituted.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = LPUART0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /** 
    *  Enable clock to Lpuart0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableLpuart0Clock();
#else
      SIM->SCGC5 = SIM->SCGC5 | SIM_SCGC5_LPUART0_MASK;
#endif
   }

   /** 
    *  Disable clock to Lpuart0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableLpuart0Clock();
#else
      SIM->SCGC5 = SIM->SCGC5 & ~SIM_SCGC5_LPUART0_MASK;
#endif
   }

   //! Default Baud rate used if not explicitly given
   static constexpr uint32_t defaultBaudRate = 115200;

   //! Default buffer size for receive queue when interrupt driven
   static constexpr unsigned receiveBufferSize = 50;

   //! Default buffer size for transmit queue when interrupt driven
   static constexpr unsigned transmitBufferSize = 50;

#if defined(PCC_PCC_LPUART0_CGC_MASK)
   //! Default clock source
   static constexpr PccDiv2Clock defaultClockSource = PccDiv2Clock_Firc;

   /**
    * Set LPUART0 input clock source.
    *
    * @param pccDiv2Clock Clock source selection
    *
    * @note This peripheral uses the DIV2 peripheral clocks e.g. SOSCDIV2_CLK 
    * @note The peripheral bus clock will be disabled before changing the 
            clock and is left disabled.
    */
   static void setClockSource(PccDiv2Clock pccDiv2Clock) {
      PccInfo::setLpuart0ClockSource(pccDiv2Clock);
   }
#endif

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getClockFrequency() {
#if defined(PCC_PCC_LPUART0_CGC_MASK)
      return PccInfo::getLpuart0Frequency();
   #elif defined(SIM_SOPT2_LPUART0SRC_MASK)
      return SimInfo::getLpuart0Clock();
   #else
      return SimInfo::getLpuartClock();
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: LPUART0_TX           = PTA3(p3)                       */  { PortAInfo,  3,            (PcrValue)0x00400UL  },
         /*   1: LPUART0_RX           = PTA4(p4)                       */  { PortAInfo,  4,            (PcrValue)0x00400UL  },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCLR = 0x0400UL|PORT_GPCLR_GPWE(0x0018UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0018UL);
   }

};

/** 
 * End group LPUART_Group
 * @}
 */
/**
 * @addtogroup Power_Group POWER, Power
 * @brief Abstraction for Power
 * @{
 */
/**
 * Peripheral information for POWER, Power.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PowerInfo {
public:
   /*
    * Template:power
    */
   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: VDD                  = VDD(p1)                        */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*   1: VSS                  = VSS(p2)                        */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
   };

};

/** 
 * End group Power_Group
 * @}
 */
/**
 * @addtogroup RCM_Group RCM, Reset Control Module
 * @brief Abstraction for Reset Control Module
 * @{
 */
/**
 * Peripheral information for RCM, Reset Control Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class RcmInfo {
public:
   /*
    * Template:rcm_mkl03z4
    */
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = RCM_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<RCM_Type> rcm = baseAddress;

   //! Reset Pin Filter Control Register
   static constexpr uint8_t rcm_rpfc = 
      RCM_RPFC_RSTFLTSS(0)|   // Reset pin filter select in stop mode
      RCM_RPFC_RSTFLTSRW(0);  // Reset pin filter select in run and wait modes

   //! Reset pin filter bus clock select
   static constexpr uint8_t rcm_rpfw = 
      RCM_RPFW_RSTFLTSEL(0); 

};

/** 
 * End group RCM_Group
 * @}
 */
/**
 * @addtogroup SMC_Group SMC, System Mode Controller
 * @brief Abstraction for System Mode Controller
 * @{
 */
/**
 * Peripheral information for SMC, System Mode Controller.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Allow very low power modes
    *
    * Allows the MCU to enter any very low power modes: VLPR, VLPW, and VLPS
    */
   enum SmcAllowVeryLowPower : uint8_t {
      SmcAllowVeryLowPower_Disabled = SMC_PMPROT_AVLP(0), ///< VLPR, VLPW and VLPS are not allowed
      SmcAllowVeryLowPower_Enabled  = SMC_PMPROT_AVLP(1), ///< VLPR, VLPW and VLPS are allowed

   };

   /**
    * Allow very low leakage stop mode
    *
    * Allows the MCU to enter any low leakage stop mode: VLLSx
    */
   enum SmcAllowVeryLowLeakageStop : uint8_t {
      SmcAllowVeryLowLeakageStop_Disabled = SMC_PMPROT_AVLLS(0), ///< VLLSx is not allowed
      SmcAllowVeryLowLeakageStop_Enabled  = SMC_PMPROT_AVLLS(1), ///< VLLSx is allowed

   };

   /**
    * Run mode
    *
    * Determines the clock speed restrictions that apply
    */
   enum SmcRunMode : uint8_t {
      SmcRunMode_Normal       = SMC_PMCTRL_RUNM(0), ///< Normal RUN
      SmcRunMode_VeryLowPower = SMC_PMCTRL_RUNM(2), ///< Very Low Power RUN

   };

   /**
    * Stop Mode Control
    *
    * Controls entry into the selected stop mode when Sleep-Now or Sleep-On-Exit 
    * mode is entered with SLEEPDEEP=1
    */
   enum SmcStopMode : uint8_t {
      SmcStopMode_NormalStop         = SMC_PMCTRL_STOPM(0), ///< Normal Stop (STOP)
      SmcStopMode_VeryLowPowerStop   = SMC_PMCTRL_STOPM(2), ///< Very-Low-Power Stop (VLPS)
      SmcStopMode_LowLeakageStop     = SMC_PMCTRL_STOPM(3), ///< Low-Leakage Stop (LLSx)
      SmcStopMode_VeryLowLeakageStop = SMC_PMCTRL_STOPM(4), ///< Very-Low-Leakage Stop (VLLSx)

   };

   /**
    * Partial Stop Mode
    *
    * Controls whether a Partial Stop mode is entered when STOPM=STOP
    */
   enum SmcPartialStopMode : uint8_t {
      SmcPartialStopMode_Normal   = SMC_STOPCTRL_PSTOPO(0), ///< STOP - Normal Stop mode
      SmcPartialStopMode_Partial1 = SMC_STOPCTRL_PSTOPO(1), ///< PSTOP1 - Partial Stop with both system and bus clocks disabled
      SmcPartialStopMode_Partial2 = SMC_STOPCTRL_PSTOPO(2), ///< PSTOP2 - Partial Stop with system clock disabled and bus clock enabled

   };

   /**
    * Power-On_Reset Detection in VLLS0 mode
    *
    * Controls whether the Power-On-Reset detect circuit is enabled in VLLS0 mode (Brown-out detection)
    */
   enum SmcPowerOnResetInVlls0 : uint8_t {
      SmcPowerOnResetInVlls0_Enabled  = SMC_STOPCTRL_PORPO(0), ///< POR detect circuit is enabled in VLLS0
      SmcPowerOnResetInVlls0_Disabled = SMC_STOPCTRL_PORPO(1), ///< POR detect circuit is disabled in VLLS0

   };

   /**
    * Stop mode LPO Option
    *
    * Controls whether the 1 kHz LPO clock is enabled in LLS/VLLSx modes
    */
   enum SmcLpoInLowLeakage : uint8_t {
      SmcLpoInLowLeakage_Disabled = SMC_STOPCTRL_LPOPO(0), ///< LPO clock is enabled in LLS/VLLSx
      SmcLpoInLowLeakage_Enabled  = SMC_STOPCTRL_LPOPO(1), ///< LPO clock is disabled in LLS/VLLSx

   };

   /**
    * Low Leakage Mode Control
    *
    * Controls which VLLS sub-mode to enter if STOPM = VLLSx
    */
   enum SmcLowLeakageStopMode : uint8_t {
      SmcLowLeakageStopMode_VLLS0 = SMC_STOPCTRL_VLLSM(0), ///< Enter VLLS0 in VLLSx mode
      SmcLowLeakageStopMode_VLLS1 = SMC_STOPCTRL_VLLSM(1), ///< Enter VLLS1 in VLLSx mode
      SmcLowLeakageStopMode_VLLS2 = SMC_STOPCTRL_VLLSM(2), ///< Enter VLLS2 in VLLSx mode
      SmcLowLeakageStopMode_VLLS3 = SMC_STOPCTRL_VLLSM(3), ///< Enter VLLS3 in VLLSx mode

   };

   /**
    * Processor execution state
    *
    * This register changes to reflect the execution state of the processor
    */
   enum SmcStatus : uint8_t {
      SmcStatus_RUN  = SMC_PMSTAT_PMSTAT(1<<0), ///< Processor is in Normal Run mode
      SmcStatus_VLPR = SMC_PMSTAT_PMSTAT(1<<2), ///< Processor is in Very Low Power Run mode
      SmcStatus_VLPW = SMC_PMSTAT_PMSTAT(1<<3), ///< Processor is in Very Low Power Wait mode
      SmcStatus_STOP = SMC_PMSTAT_PMSTAT(1<<1), ///< Processor is in Stop mode
      SmcStatus_VLPS = SMC_PMSTAT_PMSTAT(1<<4), ///< Processor is in Very Low Power Stop mode
      SmcStatus_LLS  = SMC_PMSTAT_PMSTAT(1<<5), ///< Processor is in Low Leakage Stop mode
      SmcStatus_VLLS = SMC_PMSTAT_PMSTAT(1<<6), ///< Processor is in Very Low Leakage Stop mode

   };

   consteval uint32_t make16(uint8_t pmctrl, uint8_t stopctrl=0, uint8_t bias=0) {
      return pmctrl+(stopctrl<<8)+(bias<<16);
   }

   enum SmcPowerMode {
      /*                           value                                                                                    Entry             Trans  Core       Requirements                                           */ //
      SmcPowerMode_RUN           = make16(SmcRunMode_Normal),                                                            /* (VLPR,HSRUN)->RUN 3,12   Run        SMC_PMCTRL_RUNM(0)                                     */ ///<  Run mode
      SmcPowerMode_VLPR          = make16(SmcRunMode_VeryLowPower),                                                      /* RUN->VLPR         3      Run        SMC_PMCTRL_RUNM(2)                                     */ ///<  Very low power run mode     
   
      SmcPowerMode_WAIT          = make16(SmcRunMode_Normal,0,1),                                                        /* RUN->WAIT         1      Sleep      wfi+SMC_PMCTRL_RUNM(0)                                 */ ///<  Wait mode
      SmcPowerMode_VLPW          = make16(SmcRunMode_VeryLowPower,0,1),                                                  /* VLPR->VLPW        4      Sleep      wfi+SMC_PMCTRL_RUNM(2)                                 */ ///<  Very low power wait mode
   
      SmcPowerMode_NormalSTOP    = make16(SmcRunMode_Normal|SmcStopMode_NormalStop,0,2),                                 /* RUN->STOP         2a     Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(0) RUN<->STOP           */ ///<  Stop mode                   
      SmcPowerMode_PartialSTOP1  = make16(SmcRunMode_Normal|SmcStopMode_NormalStop,SmcPartialStopMode_Partial1),         /* RUN->STOP         2b     Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(0) RUN<->STOP           */ ///<  Stop mode
      SmcPowerMode_PartialSTOP2  = make16(SmcRunMode_Normal|SmcStopMode_NormalStop,SmcPartialStopMode_Partial2),         /* RUN->STOP         2c     Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(0) RUN<->STOP           */ ///<  Stop mode                   
   
      SmcPowerMode_VLPS          = make16(SmcRunMode_Normal|SmcStopMode_VeryLowPowerStop),                               /* (RUN,VLPR)->VLPS  7,6    Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(2)                      */ ///<  Very low power stop mode
      /*                               or if SmcRunMode_VeryLowPower,                                                       VLPR->VLPS        6      Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(0/2)                    */ ///<  Very low power stop mode    
   
      SmcPowerMode_VLLS0         = make16(SmcRunMode_Normal|SmcStopMode_VeryLowLeakageStop,SmcLowLeakageStopMode_VLLS0), /* (RUN,VLPR)->VLLS0 8,9a   Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(4)+SMC_STOPCTRL_LLSM(0) */ ///<  Very low leakage stop mode 0
      SmcPowerMode_VLLS1         = make16(SmcRunMode_Normal|SmcStopMode_VeryLowLeakageStop,SmcLowLeakageStopMode_VLLS1), /* (RUN,VLPR)->VLLS1 8,9b   Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(4)+SMC_STOPCTRL_LLSM(1) */ ///<  Very low leakage stop mode 1
      SmcPowerMode_VLLS2         = make16(SmcRunMode_Normal|SmcStopMode_VeryLowLeakageStop,SmcLowLeakageStopMode_VLLS2), /* (RUN,VLPR)->VLLS2 8,9c   Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(4)+SMC_STOPCTRL_LLSM(2) */ ///<  Very low leakage stop mode 2
      SmcPowerMode_VLLS3         = make16(SmcRunMode_Normal|SmcStopMode_VeryLowLeakageStop,SmcLowLeakageStopMode_VLLS3), /* (RUN,VLPR)->VLLS3 8,9d   Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(4)+SMC_STOPCTRL_LLSM(3) */ ///<  Very low leakage stop mode 3 
   };

class SmcInfo {
public:
   /*
    * Template:smc_lpopo_mkl03z4
    */
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = SMC_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<SMC_Type> smc = baseAddress;

   /**
    * Enable all power modes.
    * A power mode must be enabled before it can be entered.
    *
    * @note This is a write-once-after-reset operation
    */
   static ErrorCode enableAllPowerModes() {
      smc->PMPROT = 0xFF;
      return E_NO_ERROR;
   }

   /**
    * Enable the given power modes
    * A mode must be enabled before it can be entered.
   
    * @note This is a write-once operation after reset
    *
    * @param smcAllowVeryLowPower       Allows the MCU to enter any very low power modes: VLPR, VLPW, and VLPS
    * @param smcAllowVeryLowLeakageStop Allows the MCU to enter any low leakage stop mode: VLLSx
    */
   static void enablePowerModes(
         SmcAllowVeryLowPower       smcAllowVeryLowPower,
         SmcAllowVeryLowLeakageStop smcAllowVeryLowLeakageStop = SmcAllowVeryLowLeakageStop_Enabled) {

      smc->PMPROT = smcAllowVeryLowPower|smcAllowVeryLowLeakageStop;
   }

   /**
    * Set Stop Mode Control
    *
    * @param smcStopMode Controls entry into the selected stop mode when Sleep-Now or Sleep-On-Exit 
    *        mode is entered with SLEEPDEEP=1
    */
   static void setStopMode(SmcStopMode smcStopMode) {
      smc->PMCTRL = (smc->PMCTRL&~SMC_PMCTRL_STOPM_MASK) | smcStopMode;
      // Make sure write completes
      (void)(smc->PMCTRL);
   }

   /**
    * Set Partial Stop Mode
    *
    * @param smcPartialStopMode Controls whether a Partial Stop mode is entered when STOPM=STOP
    */
   static void setPartialStopMode(SmcPartialStopMode smcPartialStopMode) {
      smc->STOPCTRL = (smc->STOPCTRL&~SMC_STOPCTRL_PSTOPO_MASK) | smcPartialStopMode;
   }

   /**
    * Set Power-On_Reset Detection in VLLS0 mode
    *
    * @param smcPowerOnResetInVlls0 Controls whether the Power-On-Reset detect circuit is enabled in VLLS0 mode (Brown-out detection)
    */
   static void setPowerOnResetInVLLS0(SmcPowerOnResetInVlls0 smcPowerOnResetInVlls0) {
      smc->STOPCTRL = (smc->STOPCTRL&~SMC_STOPCTRL_PORPO_MASK) | smcPowerOnResetInVlls0;
   }

   /**
    * Set Stop mode LPO Option
    *
    * @param smcLpoInLowLeakage Controls whether the 1 kHz LPO clock is enabled in LLS/VLLSx modes
    */
   static void setLpoPoweredInLLS_VLLS(SmcLpoInLowLeakage smcLpoInLowLeakage) {
      smc->STOPCTRL = (smc->STOPCTRL&~SMC_STOPCTRL_LPOPO_MASK) | smcLpoInLowLeakage;
   }

   /**
    * Set Low Leakage Mode Control
    *
    * @param smcLowLeakageStopMode Controls which VLLS sub-mode to enter if STOPM = VLLSx
    */
   static void setLowLeakageStopMode(SmcLowLeakageStopMode smcLowLeakageStopMode) {
      smc->STOPCTRL = (smc->STOPCTRL&~SMC_STOPCTRL_VLLSM_MASK) | smcLowLeakageStopMode;
   }

   /**
    * Allows the detailed operation in STOP mode to be controlled.
    *
    * @param smcPartialStopMode     Controls whether a Partial Stop mode is entered when STOPM=STOP
    * @param smcLowLeakageStopMode  Controls which VLLS sub-mode to enter if STOPM = VLLSx
    * @param smcPowerOnResetInVlls0 Controls whether the Power-On-Reset detect circuit is enabled in VLLS0 mode (Brown-out detection)
    * @param smcLpoInLowLeakage     Controls whether the 1 kHz LPO clock is enabled in LLS/VLLSx modes
    */
   static void setStopOptions(
         SmcPartialStopMode     smcPartialStopMode,
         SmcLowLeakageStopMode  smcLowLeakageStopMode  = SmcLowLeakageStopMode_VLLS3,
         SmcPowerOnResetInVlls0 smcPowerOnResetInVlls0 = SmcPowerOnResetInVlls0_Enabled,
         SmcLpoInLowLeakage     smcLpoInLowLeakage     = SmcLpoInLowLeakage_Disabled) {

      smc->STOPCTRL = smcPartialStopMode|smcLowLeakageStopMode|smcPowerOnResetInVlls0|smcLpoInLowLeakage;
   }

   /**
    * Get Processor execution state
    *
    * @param smcStatus This register changes to reflect the execution state of the processor
    *
    * @return Processor execution state
    */
   static SmcStatus getStatus() {
   
      return (SmcStatus) (smc->PMSTAT & SMC_PMSTAT_PMSTAT_MASK);
   }

   /**
    **
    * Class used to do initialisation of SMC.
    *
    * This class has a templated constructor that accepts a list of options to be configured.
    * The last parameter may be a previous instance used as a base for options.
    * Options not explicitly mentioned are cleared to 0 unless an previous value is given.
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example1: Create value in ROM
    * @code
    * // Parameters may be in any order
    * // Omitted values are taken to be zero unless a default value is given
    * // Options available vary with target - See SmcInfo::DefaultInitValue for specific example
    * static const Smc::Init smcInit{
    *    // Allow all power modes
    *    SmcAllowVeryLowPower_Enabled, SmcAllowLowLeakageStop_Enabled, SmcAllowVeryLowLeakageStop_Enabled,
    *    // Partial Stop mode to use
    *    SmcPartialStopMode_Partial2,
    *    // (Very) Low leakage stop mode to use
    *    SmcLowLeakageStopMode_LLS3,
    *    // Allow brown-out detection in VLLS0
    *    SmcPowerOnResetInVlls0_Enabled,
    *    // Power RAM2 in in LLS2/VLLS2 mode
    *    SmcLowLeakageRam2_Enabled,
    *    // Stop mode to enter on Deep-sleep
    *    SmcStopMode_NormalStop
    *    // Optional value to build upon - must be last in parameter list
    *    // The value below is generated from Configure.usbdmProject
    *    Smc::DefaultInitValue,
    * };
    *
    * // This version initialises all registers including write-once
    * // Use for initial setup
    * smcInit.initialise();
    *
    * // This version initialises all registers apart from write-once
    * // It may be used to change settings later
    * smcInit.setOptions();
    *
    * The value can also be used with enterStopMode()
    * Smc::enterStopMode(smcInit);
    * @endcode
    *
    * Example2: Inline example
    * @code
    * Smc::Init{
    *    // Stop mode to enter on Deep-sleep
    *    SmcStopMode_NormalStop,
    *    // The value below is generated from Configure.usbdmProject
    *    Smc::DefaultInitValue}.setOptions();
    * @endcode
    */
   class Init {
   
   public:
     /**
      * Value for PMPROT register
      * Note: This is a write-once register
      */
      uint8_t pmprot    = 0;
   
      /**
       * Value for PMCTRL register
       * The PMCTRL register controls entry into low-power Run and Stop modes.
       * Note: This variable ONLY contains the STOPM field
       */
      uint8_t pmctrl    = 0;
   
      /**
       * Value for STOPCTRL register
       * The STOPCTRL register provides various control bits allowing the user to fine tune
       * power consumption during the stop mode selected by the STOPM field.
       */
      uint8_t stopctrl  = 0;
   
   public:
      /**
       * Configure STOP mode options as specified in the constructor.
       * This does not include write-once registers.
       */
      inline void setOptions() const {
         smc->STOPCTRL  = stopctrl;
         smc->PMCTRL    = (smc->PMCTRL & ~(SMC_PMCTRL_STOPM_MASK))|pmctrl;
      }
   
      /**
       * Configure all STOP mode options as specified in the constructor.
       * This includes write-once registers
       */
      inline void initialise() const {
         smc->PMPROT    = pmprot;
         setOptions();
      }
   
      /**
       * Read the current STOP mode options from hardware registers
       */
      void readConfig() {
         pmprot   = smc->PMPROT;
         stopctrl = smc->STOPCTRL;
         pmctrl   = smc->PMCTRL & SMC_PMCTRL_STOPM_MASK;
      }
   
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Constructor
       */
      constexpr Init() = default;

      /**
       * Constructor - Allow very low power modes
       *
       * @note - This value is only used by initialise() method to set write-once register PMPROT
       *
       * @tparam   Types
       * @param    rest
       *
       * @param smcAllowVeryLowPower Allows the MCU to enter any very low power modes: VLPR, VLPW, and VLPS
       */
      template <typename... Types>
      constexpr Init(SmcAllowVeryLowPower smcAllowVeryLowPower, Types... rest) : Init(rest...) {
         pmprot = (pmprot&~SMC_PMPROT_AVLP_MASK) | smcAllowVeryLowPower;
      }

      /**
       * Constructor - Allow very low leakage stop mode
       *
       * @note - This value is only used by initialise() method to set write-once register PMPROT
       *
       * @tparam   Types
       * @param    rest
       *
       * @param smcAllowVeryLowLeakageStop Allows the MCU to enter any low leakage stop mode: VLLSx
       */
      template <typename... Types>
      constexpr Init(SmcAllowVeryLowLeakageStop smcAllowVeryLowLeakageStop, Types... rest) : Init(rest...) {
         pmprot = (pmprot&~SMC_PMPROT_AVLLS_MASK) | smcAllowVeryLowLeakageStop;
      }

      /**
       * Constructor - Partial Stop Mode
       *
       *
       * @tparam   Types
       * @param    rest
       *
       * @param smcPartialStopMode Controls whether a Partial Stop mode is entered when STOPM=STOP
       */
      template <typename... Types>
      constexpr Init(SmcPartialStopMode smcPartialStopMode, Types... rest) : Init(rest...) {
         stopctrl = (stopctrl&~SMC_STOPCTRL_PSTOPO_MASK) | smcPartialStopMode;
      }

      /**
       * Constructor - Power-On_Reset Detection in VLLS0 mode
       *
       *
       * @tparam   Types
       * @param    rest
       *
       * @param smcPowerOnResetInVlls0 Controls whether the Power-On-Reset detect circuit is enabled in VLLS0 mode (Brown-out detection)
       */
      template <typename... Types>
      constexpr Init(SmcPowerOnResetInVlls0 smcPowerOnResetInVlls0, Types... rest) : Init(rest...) {
         stopctrl = (stopctrl&~SMC_STOPCTRL_PORPO_MASK) | smcPowerOnResetInVlls0;
      }

      /**
       * Constructor - Stop mode LPO Option
       *
       *
       * @tparam   Types
       * @param    rest
       *
       * @param smcLpoInLowLeakage Controls whether the 1 kHz LPO clock is enabled in LLS/VLLSx modes
       */
      template <typename... Types>
      constexpr Init(SmcLpoInLowLeakage smcLpoInLowLeakage, Types... rest) : Init(rest...) {
         stopctrl = (stopctrl&~SMC_STOPCTRL_LPOPO_MASK) | smcLpoInLowLeakage;
      }

      /**
       * Constructor - Low Leakage Mode Control
       *
       *
       * @tparam   Types
       * @param    rest
       *
       * @param smcLowLeakageStopMode Controls which VLLS sub-mode to enter if STOPM = VLLSx
       */
      template <typename... Types>
      constexpr Init(SmcLowLeakageStopMode smcLowLeakageStopMode, Types... rest) : Init(rest...) {
         stopctrl = (stopctrl&~SMC_STOPCTRL_VLLSM_MASK) | smcLowLeakageStopMode;
      }

      /**
       * Constructor - Stop Mode Control
       *
       *
       * @tparam   Types
       * @param    rest
       *
       * @param smcStopMode Controls entry into the selected stop mode when Sleep-Now or Sleep-On-Exit 
       *        mode is entered with SLEEPDEEP=1
       */
      template <typename... Types>
      constexpr Init(SmcStopMode smcStopMode, Types... rest) : Init(rest...) {
         pmctrl = (pmctrl&~SMC_PMCTRL_STOPM_MASK) | smcStopMode;
      }

   };

};

/** 
 * End group SMC_Group
 * @}
 */
/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief Abstraction for Serial Peripheral Interface
 * @{
 */
/**
 * Peripheral information for SPI, Serial Peripheral Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Spi0Info {
public:
   /*
    * Template:spi0_mkl_8bit
    */
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = SPI0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<SPI_Type> spi = baseAddress;

   //! Pin number in Info table for SCK if mapped to a pin
   static constexpr int sckPin  = 0;

   //! Pin number in Info table for SIN if mapped to a pin
   static constexpr int sinPin  = 1;

   //! Pin number in Info table for SOUT if mapped to a pin
   static constexpr int soutPin  = 2;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = SPI0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_Normal;

   /** 
    *  Enable clock to Spi0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableSpi0Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_SPI0_MASK;
#endif
   }

   /** 
    *  Disable clock to Spi0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableSpi0Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_SPI0_MASK;
#endif
   }

   //! Default communication mode: order, clock phase and clock polarity
   static constexpr uint8_t modeValue = 
      SPI_C1_LSBFE(0)| // LSB or MSB first
      SPI_C1_MODE(0);  // Mode (CPOL+CPHA)

   static uint32_t getClockFrequency() {
      return SystemBusClock;
   }

   //! Default speed (Hz)
   static constexpr uint32_t speed = 
      10000000;

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: SPI0_SCK             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: SPI0_MISO            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: SPI0_MOSI            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: SPI0_SS_b            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group SPI_Group
 * @}
 */
/**
 * @addtogroup TPM_Group TPM, PWM, Input capture and Output compare
 * @brief Abstraction for PWM, Input capture and Output compare
 * @{
 */
/**
 * Peripheral information for TPM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class TpmInfo {
public:
   /*
    * Template:tpm
    */

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: TPM_CLKIN0           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: TPM_CLKIN1           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/**
 * Peripheral information for TPM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Clock Source
    *
    * Selects the clock source for the module
    */
   enum TpmClockSource : uint16_t {
      TpmClockSource_Disabled       = TPM_SC_CMOD(0), ///< Disabled
      TpmClockSource_SystemTpmClock = TPM_SC_CMOD(1), ///< System TPM Clock
      TpmClockSource_ExternalClock  = TPM_SC_CMOD(2), ///< External clock

   };

   /**
    * Clock prescaler
    *
    * Selects the prescaler for the module
    */
   enum TpmPrescale : uint16_t {
      TpmPrescale_DivBy1   = TPM_SC_PS(0), ///< Divide by 1
      TpmPrescale_DivBy2   = TPM_SC_PS(1), ///< Divide by 2
      TpmPrescale_DivBy4   = TPM_SC_PS(2), ///< Divide by 4
      TpmPrescale_DivBy8   = TPM_SC_PS(3), ///< Divide by 8
      TpmPrescale_DivBy16  = TPM_SC_PS(4), ///< Divide by 16
      TpmPrescale_DivBy32  = TPM_SC_PS(5), ///< Divide by 32
      TpmPrescale_DivBy64  = TPM_SC_PS(6), ///< Divide by 64
      TpmPrescale_DivBy128 = TPM_SC_PS(7), ///< Divide by 128

   };

   /**
    * Alignment and whether interval or free-running mode
    *
    * Left-aligned   (0...mod) or
    * Centre-aligned (0...mod...0) or
    * Free-running   (0...maximum_value)
    */
   enum TpmMode : uint16_t {
      TpmMode_LeftAligned   = TPM_SC_TOF(0)|TPM_SC_CPWMS(0), ///< Left-aligned (count up)
      TpmMode_CentreAligned = TPM_SC_TOF(0)|TPM_SC_CPWMS(1), ///< Centre-aligned (count up-down)
      TpmMode_FreeRunning   = TPM_SC_TOF(1)|TPM_SC_CPWMS(0), ///< Free-running (count up)

   };

   /**
    * Action on Counter overflow
    *
    * Enable interrupt on counter overflow
    */
   enum TpmOverflowAction : uint16_t {
      TpmOverflowAction_None      = TPM_SC_TOIE(0), ///< No action
      TpmOverflowAction_Interrupt = TPM_SC_TOIE(1), ///< Overflow Interrupt

   };

   /**
    * Channel Number
    *
    * Select a channel
    */
   enum TpmChannelNum : uint8_t {
      TpmChannelNum_0    = 0,             ///< Channel 0
      TpmChannelNum_1    = 1,             ///< Channel 1
      TpmChannelNum_2    = 2,             ///< Channel 2
      TpmChannelNum_3    = 3,             ///< Channel 3
      TpmChannelNum_4    = 4,             ///< Channel 4
      TpmChannelNum_5    = 5,             ///< Channel 5
      TpmChannelNum_6    = 6,             ///< Channel 6
      TpmChannelNum_7    = 7,             ///< Channel 7
      TpmChannelNum_None = (uint8_t(-1)), ///< No Channel

   };

   /**
    * Channel Mode
    *
    * Determines channel operation (PWM/Input capture/Output compare)
    */
   enum TpmChannelMode : uint16_t {
      TpmChannelMode_Disabled                = TPM_CnSC_MS(0)|TPM_CnSC_ELS(0), ///< Disabled
      TpmChannelMode_InputCaptureRisingEdge  = TPM_CnSC_MS(0)|TPM_CnSC_ELS(1), ///< Input Capture Rising-edge
      TpmChannelMode_InputCaptureFallingEdge = TPM_CnSC_MS(0)|TPM_CnSC_ELS(2), ///< Input Capture Falling-edge
      TpmChannelMode_InputCaptureEitherEdge  = TPM_CnSC_MS(0)|TPM_CnSC_ELS(3), ///< Input Capture Either-edge
      TpmChannelMode_OutputCompare           = TPM_CnSC_MS(1)|TPM_CnSC_ELS(0), ///< Output Compare No action
      TpmChannelMode_OutputCompareToggle     = TPM_CnSC_MS(1)|TPM_CnSC_ELS(1), ///< Output Compare Toggle
      TpmChannelMode_OutputCompareClear      = TPM_CnSC_MS(1)|TPM_CnSC_ELS(2), ///< Output Compare Clear
      TpmChannelMode_OutputCompareSet        = TPM_CnSC_MS(1)|TPM_CnSC_ELS(3), ///< Output Compare Set
      TpmChannelMode_PwmHighTruePulses       = TPM_CnSC_MS(2)|TPM_CnSC_ELS(2), ///< Pwm High-true Pulses
      TpmChannelMode_PwmLowTruePulses        = TPM_CnSC_MS(2)|TPM_CnSC_ELS(1), ///< Pwm Low-true Pulses

   };

   /**
    * Action on Channel Event
    *
    * Enable interrupt on channel event
    */
   enum TpmChannelAction : uint8_t {
      TpmChannelAction_None      = TPM_CnSC_CHIE(0), ///< No action
      TpmChannelAction_Interrupt = TPM_CnSC_CHIE(1), ///< Interrupt request

   };

class Tpm0BasicInfo {
   
public:

   /**
    * Type definition for Tpm0 Peripheral interrupt handling call back.
    */
   typedef void (*CallbackFunction)();

   /**
    * Class used to do initialisation of Tpm0
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Tpm0::Init tpmInit {
    *
    *    // Omitted parameters are taken to be zero unless a base value is given
    *    TpmMode_Freerunning,           // Alignment and whether interval or free-running mode
    *    TpmOverflowInterrupt_Disabled, // Overflow Interrupt
    *    NvicPriority_Normal,           // IRQ level for this peripheral
    *    TpmClockSource_SystemClock,    // Clock Source
    *
    *    // Either
    *    TpmPrescale_DivBy16,           // Clock prescaler
    *    10_ticks, 3000_ticks,          // Counter start (cntin) and end (mod) values
    *    // OR
    *    100_ms,                        // Timer period or minimum interval in seconds
    *
    *    // Optional base value to start with (must be last parameter)
    *    Tpm0::DefaultValue
    * };
    *
    * // Initialise TPM from values specified above
    * Tpm0::configure(tpmInit)
    * @endcode
    */
   class Init {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      /// Peripheral interrupt handling
      CallbackFunction callbackFunction = nullptr;

      /// Status And Control Register
      uint8_t sc = 0;

      /// IRQ priority levels
      NvicPriority irqlevel = NvicPriority_Normal;

      /// End value for counter
      uint16_t mod = 0_ticks;

      /// Period or minimum interval of timer
      Seconds modperiod = 0_s;

      /**
       * Constructor for Peripheral interrupt handling
       *
       * @tparam   Types
       * @param    rest
       *
       * @param callbackFunction If enabled, the handler may be set using the setCallback() function or
       *        by overriding the interrupt handler method in the peripheral class
       *        If not enabled, then interrupt handlers may be installed by naming them 
       *        (see weak names used in vector table).
       */
      template <typename... Types>
      constexpr Init(CallbackFunction callbackFunction, Types... rest) : Init(rest...) {
   
         this->callbackFunction = callbackFunction;
      }

      /**
       * Constructor for IRQ priority levels
       *
       * @tparam   Types
       * @param    rest
       *
       * @param nvicPriority Priority level used to configure the NVIC
       *        Subset of available levels
       */
      template <typename... Types>
      constexpr Init(NvicPriority nvicPriority, Types... rest) : Init(rest...) {
   
#if true
         irqlevel = nvicPriority;
#else
         (void)nvicPriority;
#endif
      }

      /**
       * Constructor for Action on Counter overflow
       *
       * @tparam   Types
       * @param    rest
       *
       * @param tpmOverflowAction Enable interrupt on counter overflow
       */
      template <typename... Types>
      constexpr Init(TpmOverflowAction tpmOverflowAction, Types... rest) : Init(rest...) {
   
         sc = (sc&~TPM_SC_TOIE_MASK) | tpmOverflowAction;
      }
   
      /**
       * Constructor for Alignment and whether interval or free-running mode
       *
       * @tparam   Types
       * @param    rest
       *
       * @param tpmMode Left-aligned   (0...mod) or
       *        Centre-aligned (0...mod...0) or
       *        Free-running   (0...maximum_value)
       */
      template <typename... Types>
      constexpr Init(TpmMode tpmMode, Types... rest) : Init(rest...) {
   
         sc = (sc&~(TPM_SC_TOF_MASK|TPM_SC_CPWMS_MASK)) | tpmMode;
      }
   
      /**
       * Constructor for Clock Source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param tpmClockSource Selects the clock source for the module
       */
      template <typename... Types>
      constexpr Init(TpmClockSource tpmClockSource, Types... rest) : Init(rest...) {
   
         sc = (sc&~TPM_SC_CMOD_MASK) | tpmClockSource;
      }
   
      /**
       * Constructor for Clock prescaler and End value for counter
       *
       * @tparam   Types
       * @param    rest
       *
       * @param tpmPrescale Selects the prescaler for the module
       * @param mod_ticks   The timer counts from 0 to this value
       */
      template <typename... Types>
      constexpr Init(
            TpmPrescale tpmPrescale,
            Ticks&      mod_ticks, Types... rest) : Init(rest...) {
   
         sc    = (sc&~TPM_SC_PS_MASK) | tpmPrescale;
         mod   = mod_ticks;
      }
   
      /**
       * Constructor for Period or minimum interval of timer
       *
       * @tparam   Types
       * @param    rest
       *
       * @param seconds   In left-aligned or centre-aligned this is the period of the timer
       *        In free-running mode it is the minimum interval
       */
      template <typename... Types>
      constexpr Init(Seconds&  seconds, Types... rest) : Init(rest...) {
   
         mod   = 0;
         modperiod = seconds;
      }
   
   };

   /**
    * Class used to do initialisation of Tpm0Channel
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Tpm0::ChannelInit channelInit {
    *
    *    // Omitted parameters are taken to be zero unless a base value is given
    *    TpmChannelNum_3,            // Channel to initialise
    *    TpmChannelMode_Disabled ,   // Channel Mode - Disabled
    *    TpmChannelAction_None ,     // Action on Channel Event - No action
    *    TpmChannelReset_Disabled ,  // Reset counter on channel IC event - Disabled
    *    0_ticks,                    // Output Compare Event time
    *
    *    // Optional base value to start with (must be last parameter)
    *    Tpm0::DefaultChannelInitValues[TpmChannelNum_3]
    * };
    *
    * // Initialise TPM from values specified above
    * Tpm0::configureChannel(channelInit)
    * @endcode
    */
   class ChannelInit {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr ChannelInit(const ChannelInit &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr ChannelInit() = default;
   
      /// Output Compare Event time in ticks
      uint16_t cnv = 0_ticks;

      /// Channel Status And Control Register
      uint16_t cnsc = 0;

      /// Channel Number
      TpmChannelNum channel = TpmChannelNum_None;

      /**
       * Constructor for Channel Mode
       *
       * @tparam   Types
       * @param    rest
       * @param tpmChannelMode Determines channel operation (PWM/Input capture/Output compare)
       */
      template <typename... Types>
      constexpr ChannelInit(TpmChannelMode tpmChannelMode, Types... rest) : ChannelInit(rest...) {
   
         cnsc = (cnsc&~(TPM_CnSC_MS_MASK|TPM_CnSC_ELS_MASK)) | tpmChannelMode;
      }
   
      /**
       * Constructor for Action on Channel Event
       *
       * @tparam   Types
       * @param    rest
       * @param tpmChannelAction Enable interrupt on channel event
       */
      template <typename... Types>
      constexpr ChannelInit(TpmChannelAction tpmChannelAction, Types... rest) : ChannelInit(rest...) {
   
         cnsc = (cnsc&~TPM_CnSC_CHIE_MASK) | tpmChannelAction;
      }
   
      /**
       * Constructor for Channel Number
       *
       * @tparam   Types
       * @param    rest
       * @param tpmChannelNum Select a channel
       */
      template <typename... Types>
      constexpr ChannelInit(TpmChannelNum tpmChannelNum, Types... rest) : ChannelInit(rest...) {
   
         channel = tpmChannelNum;
      }
   
      /**
       * Constructor for Output Compare Event time in ticks
       *
       * @tparam   Types
       * @param    rest
       * @param ticks   This value is compared against the main counter in output compare modes
       */
      template <typename... Types>
      constexpr ChannelInit(Ticks&  ticks, Types... rest) : ChannelInit(rest...) {
   
         cnv = ticks;
      }
   
   };

};

extern void unhandledCallback(uint8_t);
extern void timerUnhandledChannelCallback(uint8_t);

class Tpm0Info {
public:
   /*
    * Template:tpm0_2ch_no_dma
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Number of channels implemented
   static constexpr unsigned NumChannels = 2;

   //! Number of channel event vectors implemented
   static constexpr unsigned NumChannelVectors = 1;

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = TPM0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<TPM_Type> tpm = baseAddress;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = TPM0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = true;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_Normal;

   /// Minimum resolution for PWM interval
   static constexpr uint32_t minimumResolution  = 100;

   /// Minimum usable interval in ticks
   static constexpr uint32_t minimumInterval  = 20;

   /// TPM External clock
   static constexpr uint32_t tpmExternalClock =  0;   /**
    * Get Clock Source
    *
    * @param tpmClockSource Selects the clock source for the module
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getInputClockFrequency(TpmClockSource tpmClockSource) {
   
      switch(tpmClockSource) {
         default: return 0;
         case TpmClockSource_Disabled       : return 0;                      ///< Disabled
         case TpmClockSource_SystemTpmClock : return SimInfo::getTpmClock(); ///< System TPM Clock
         case TpmClockSource_ExternalClock  : return tpmExternalClock;       ///< External clock

      }
   }

   /**
    * Class used to do initialisation of Tpm0
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Tpm0::Init tpmInit {
    *
    *    // Omitted parameters are taken to be zero unless a base value is given
    *    TpmMode_Freerunning,           // Alignment and whether interval or free-running mode
    *    TpmOverflowInterrupt_Disabled, // Overflow Interrupt
    *    NvicPriority_Normal,           // IRQ level for this peripheral
    *    TpmClockSource_SystemClock,    // Clock Source
    *
    *    // Either
    *    TpmPrescale_DivBy16,           // Clock prescaler
    *    10_ticks, 3000_ticks,          // Counter start (cntin) and end (mod) values
    *    // OR
    *    100_ms,                        // Timer period or minimum interval in seconds
    *
    *    // Optional base value to start with (must be last parameter)
    *    Tpm0::DefaultValue
    * };
    *
    * // Initialise TPM from values specified above
    * Tpm0::configure(tpmInit)
    * @endcode
    */
   typedef Tpm0BasicInfo::Init Init;
   
   /**
    * Tpm0 interrupt call back
    */
   typedef Tpm0BasicInfo::CallbackFunction CallbackFunction;
   
   /**
    * Default initialisation value for Tpm0
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr Init DefaultInitValue = {
      TpmMode_FreeRunning , // Alignment and whether interval or free-running mode - Free-running (count up)
      TpmOverflowAction_None , // Action on Counter overflow - No action
      NvicPriority_Normal , // IRQ level for this peripheral - Normal
      TpmClockSource_SystemTpmClock , // Clock Source - System TPM Clock
      TpmPrescale_DivBy4 , // Clock prescaler - Divide by 4
      65535_ticks,  // End value for counter
   };

   /**
    * Class used to do initialisation of Tpm0Channel
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Tpm0::ChannelInit channelInit {
    *
    *    // Omitted parameters are taken to be zero unless a base value is given
    *    TpmChannelNum_3,            // Channel to initialise
    *    TpmChannelMode_Disabled ,   // Channel Mode - Disabled
    *    TpmChannelAction_None ,     // Action on Channel Event - No action
    *    TpmChannelReset_Disabled ,  // Reset counter on channel IC event - Disabled
    *    0_ticks,                    // Output Compare Event time
    *
    *    // Optional base value to start with (must be last parameter)
    *    Tpm0::DefaultChannelInitValues[TpmChannelNum_3]
    * };
    *
    * // Initialise TPM from values specified above
    * Tpm0::configureChannel(channelInit)
    * @endcode
    */
   typedef Tpm0BasicInfo::ChannelInit ChannelInit;
   
   /**
    * Default initialisation value for Tpm0ChannelInit
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr ChannelInit DefaultChannelInitValues[] = {
   {
      TpmChannelNum_0,

      TpmChannelMode_Disabled , // Channel Mode - Disabled
      TpmChannelAction_None , // Action on Channel Event - No action
      0_ticks,  // Output Compare Event time in ticks
   },
   {
      TpmChannelNum_1,

      TpmChannelMode_Disabled , // Channel Mode - Disabled
      TpmChannelAction_None , // Action on Channel Event - No action
      0_ticks,  // Output Compare Event time in ticks
   },

   };

   /**
    * Type definition for channel interrupt call back
    *
    * @param[in] status Flags indicating interrupt source channel(s)
    */
   typedef void (*ChannelCallbackFunction)(uint8_t status);
   
   /**
    * Callback table for programmatically set handlers
    */
   static ChannelCallbackFunction channelCallbacks[1];

   /**
    * Set channel Callback function

    * Note that one callback is shared by all channels of the timer
    *
    * @param[in] callback Callback function to execute on channel interrupt.

    *                     Use nullptr to remove callback.
    *
    * @return E_NO_ERROR            No error
    * @return E_HANDLER_ALREADY_SET Handler already set
    *
    * @note Channel callbacks may be shared by multiple channels of the timer.
    *       It is necessary to identify the originating channel in the callback
    */
   static ErrorCode setChannelCallback(ChannelCallbackFunction callback) {
      if (callback == nullptr) {
         channelCallbacks[0] = timerUnhandledChannelCallback;
         return E_NO_ERROR;
      }
#ifdef DEBUG_BUILD
      // Callback is shared across multiple channels. Check if callback already assigned
      if ((channelCallbacks[0] != timerUnhandledChannelCallback) &&
          (channelCallbacks[0] != callback)) {
         return setErrorCode(ErrorCode::E_HANDLER_ALREADY_SET);
      }
#endif
      channelCallbacks[0] = callback;
      return E_NO_ERROR;
   }

   /** 
    *  Enable clock to Tpm0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableTpm0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_TPM0_MASK;
#endif
   }

   /** 
    *  Disable clock to Tpm0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableTpm0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_TPM0_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 10;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: TPM0_CH0             = PTA6(p6)                       */  { PortAInfo,  6,            (PcrValue)0x00200UL  },
         /*   1: TPM0_CH1             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   3: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   4: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   5: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   6: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   7: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   8: TPM_CLKIN0           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   9: TPM_CLKIN1           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCLR = 0x0200UL|PORT_GPCLR_GPWE(0x0040UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0040UL);
   }

};

/**
 * Peripheral information for TPM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Tpm1BasicInfo {
   
public:

   /**
    * Type definition for Tpm1 Peripheral interrupt handling call back.
    */
   typedef void (*CallbackFunction)();

   /**
    * Class used to do initialisation of Tpm1
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Tpm1::Init tpmInit {
    *
    *    // Omitted parameters are taken to be zero unless a base value is given
    *    TpmMode_Freerunning,           // Alignment and whether interval or free-running mode
    *    TpmOverflowInterrupt_Disabled, // Overflow Interrupt
    *    NvicPriority_Normal,           // IRQ level for this peripheral
    *    TpmClockSource_SystemClock,    // Clock Source
    *
    *    // Either
    *    TpmPrescale_DivBy16,           // Clock prescaler
    *    10_ticks, 3000_ticks,          // Counter start (cntin) and end (mod) values
    *    // OR
    *    100_ms,                        // Timer period or minimum interval in seconds
    *
    *    // Optional base value to start with (must be last parameter)
    *    Tpm1::DefaultValue
    * };
    *
    * // Initialise TPM from values specified above
    * Tpm1::configure(tpmInit)
    * @endcode
    */
   class Init {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      /// Status And Control Register
      uint8_t sc = 0;

      /// End value for counter
      uint16_t mod = 0_ticks;

      /// Period or minimum interval of timer
      Seconds modperiod = 0_s;

      /**
       * Constructor for IRQ priority levels
       *
       * @tparam   Types
       * @param    rest
       *
       * @param nvicPriority Priority level used to configure the NVIC
       *        Subset of available levels
       */
      template <typename... Types>
      constexpr Init(NvicPriority nvicPriority, Types... rest) : Init(rest...) {
   
#if false
         irqlevel = nvicPriority;
#else
         (void)nvicPriority;
#endif
      }

      /**
       * Constructor for Action on Counter overflow
       *
       * @tparam   Types
       * @param    rest
       *
       * @param tpmOverflowAction Enable interrupt on counter overflow
       */
      template <typename... Types>
      constexpr Init(TpmOverflowAction tpmOverflowAction, Types... rest) : Init(rest...) {
   
         sc = (sc&~TPM_SC_TOIE_MASK) | tpmOverflowAction;
      }
   
      /**
       * Constructor for Alignment and whether interval or free-running mode
       *
       * @tparam   Types
       * @param    rest
       *
       * @param tpmMode Left-aligned   (0...mod) or
       *        Centre-aligned (0...mod...0) or
       *        Free-running   (0...maximum_value)
       */
      template <typename... Types>
      constexpr Init(TpmMode tpmMode, Types... rest) : Init(rest...) {
   
         sc = (sc&~(TPM_SC_TOF_MASK|TPM_SC_CPWMS_MASK)) | tpmMode;
      }
   
      /**
       * Constructor for Clock Source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param tpmClockSource Selects the clock source for the module
       */
      template <typename... Types>
      constexpr Init(TpmClockSource tpmClockSource, Types... rest) : Init(rest...) {
   
         sc = (sc&~TPM_SC_CMOD_MASK) | tpmClockSource;
      }
   
      /**
       * Constructor for Clock prescaler and End value for counter
       *
       * @tparam   Types
       * @param    rest
       *
       * @param tpmPrescale Selects the prescaler for the module
       * @param mod_ticks   The timer counts from 0 to this value
       */
      template <typename... Types>
      constexpr Init(
            TpmPrescale tpmPrescale,
            Ticks&      mod_ticks, Types... rest) : Init(rest...) {
   
         sc    = (sc&~TPM_SC_PS_MASK) | tpmPrescale;
         mod   = mod_ticks;
      }
   
      /**
       * Constructor for Period or minimum interval of timer
       *
       * @tparam   Types
       * @param    rest
       *
       * @param seconds   In left-aligned or centre-aligned this is the period of the timer
       *        In free-running mode it is the minimum interval
       */
      template <typename... Types>
      constexpr Init(Seconds&  seconds, Types... rest) : Init(rest...) {
   
         mod   = 0;
         modperiod = seconds;
      }
   
   };

   /**
    * Class used to do initialisation of Tpm1Channel
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Tpm1::ChannelInit channelInit {
    *
    *    // Omitted parameters are taken to be zero unless a base value is given
    *    TpmChannelNum_3,            // Channel to initialise
    *    TpmChannelMode_Disabled ,   // Channel Mode - Disabled
    *    TpmChannelAction_None ,     // Action on Channel Event - No action
    *    TpmChannelReset_Disabled ,  // Reset counter on channel IC event - Disabled
    *    0_ticks,                    // Output Compare Event time
    *
    *    // Optional base value to start with (must be last parameter)
    *    Tpm1::DefaultChannelInitValues[TpmChannelNum_3]
    * };
    *
    * // Initialise TPM from values specified above
    * Tpm1::configureChannel(channelInit)
    * @endcode
    */
   class ChannelInit {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr ChannelInit(const ChannelInit &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr ChannelInit() = default;
   
      /// Output Compare Event time in ticks
      uint16_t cnv = 0_ticks;

      /// Channel Status And Control Register
      uint16_t cnsc = 0;

      /// Channel Number
      TpmChannelNum channel = TpmChannelNum_None;

      /**
       * Constructor for Channel Mode
       *
       * @tparam   Types
       * @param    rest
       * @param tpmChannelMode Determines channel operation (PWM/Input capture/Output compare)
       */
      template <typename... Types>
      constexpr ChannelInit(TpmChannelMode tpmChannelMode, Types... rest) : ChannelInit(rest...) {
   
         cnsc = (cnsc&~(TPM_CnSC_MS_MASK|TPM_CnSC_ELS_MASK)) | tpmChannelMode;
      }
   
      /**
       * Constructor for Action on Channel Event
       *
       * @tparam   Types
       * @param    rest
       * @param tpmChannelAction Enable interrupt on channel event
       */
      template <typename... Types>
      constexpr ChannelInit(TpmChannelAction tpmChannelAction, Types... rest) : ChannelInit(rest...) {
   
         cnsc = (cnsc&~TPM_CnSC_CHIE_MASK) | tpmChannelAction;
      }
   
      /**
       * Constructor for Channel Number
       *
       * @tparam   Types
       * @param    rest
       * @param tpmChannelNum Select a channel
       */
      template <typename... Types>
      constexpr ChannelInit(TpmChannelNum tpmChannelNum, Types... rest) : ChannelInit(rest...) {
   
         channel = tpmChannelNum;
      }
   
      /**
       * Constructor for Output Compare Event time in ticks
       *
       * @tparam   Types
       * @param    rest
       * @param ticks   This value is compared against the main counter in output compare modes
       */
      template <typename... Types>
      constexpr ChannelInit(Ticks&  ticks, Types... rest) : ChannelInit(rest...) {
   
         cnv = ticks;
      }
   
   };

};

class Tpm1Info {
public:
   /*
    * Template:tpm0_2ch_no_dma
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Number of channels implemented
   static constexpr unsigned NumChannels = 2;

   //! Number of channel event vectors implemented
   static constexpr unsigned NumChannelVectors = 1;

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = TPM1_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<TPM_Type> tpm = baseAddress;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = TPM1_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_Normal;

   /// Minimum resolution for PWM interval
   static constexpr uint32_t minimumResolution  = 100;

   /// Minimum usable interval in ticks
   static constexpr uint32_t minimumInterval  = 20;

   /// TPM External clock
   static constexpr uint32_t tpmExternalClock =  0;   /**
    * Get Clock Source
    *
    * @param tpmClockSource Selects the clock source for the module
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getInputClockFrequency(TpmClockSource tpmClockSource) {
   
      switch(tpmClockSource) {
         default: return 0;
         case TpmClockSource_Disabled       : return 0;                      ///< Disabled
         case TpmClockSource_SystemTpmClock : return SimInfo::getTpmClock(); ///< System TPM Clock
         case TpmClockSource_ExternalClock  : return tpmExternalClock;       ///< External clock

      }
   }

   /**
    * Class used to do initialisation of Tpm1
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Tpm1::Init tpmInit {
    *
    *    // Omitted parameters are taken to be zero unless a base value is given
    *    TpmMode_Freerunning,           // Alignment and whether interval or free-running mode
    *    TpmOverflowInterrupt_Disabled, // Overflow Interrupt
    *    NvicPriority_Normal,           // IRQ level for this peripheral
    *    TpmClockSource_SystemClock,    // Clock Source
    *
    *    // Either
    *    TpmPrescale_DivBy16,           // Clock prescaler
    *    10_ticks, 3000_ticks,          // Counter start (cntin) and end (mod) values
    *    // OR
    *    100_ms,                        // Timer period or minimum interval in seconds
    *
    *    // Optional base value to start with (must be last parameter)
    *    Tpm1::DefaultValue
    * };
    *
    * // Initialise TPM from values specified above
    * Tpm1::configure(tpmInit)
    * @endcode
    */
   typedef Tpm1BasicInfo::Init Init;
   
   /**
    * Tpm1 interrupt call back
    */
   typedef Tpm1BasicInfo::CallbackFunction CallbackFunction;
   
   /**
    * Default initialisation value for Tpm1
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr Init DefaultInitValue = {
      TpmMode_FreeRunning , // Alignment and whether interval or free-running mode - Free-running (count up)
      TpmOverflowAction_None , // Action on Counter overflow - No action
      NvicPriority_Normal , // IRQ level for this peripheral - Normal
      TpmClockSource_SystemTpmClock , // Clock Source - System TPM Clock
      TpmPrescale_DivBy16 , // Clock prescaler - Divide by 16
      65535_ticks,  // End value for counter
   };

   /**
    * Class used to do initialisation of Tpm1Channel
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Tpm1::ChannelInit channelInit {
    *
    *    // Omitted parameters are taken to be zero unless a base value is given
    *    TpmChannelNum_3,            // Channel to initialise
    *    TpmChannelMode_Disabled ,   // Channel Mode - Disabled
    *    TpmChannelAction_None ,     // Action on Channel Event - No action
    *    TpmChannelReset_Disabled ,  // Reset counter on channel IC event - Disabled
    *    0_ticks,                    // Output Compare Event time
    *
    *    // Optional base value to start with (must be last parameter)
    *    Tpm1::DefaultChannelInitValues[TpmChannelNum_3]
    * };
    *
    * // Initialise TPM from values specified above
    * Tpm1::configureChannel(channelInit)
    * @endcode
    */
   typedef Tpm1BasicInfo::ChannelInit ChannelInit;
   
   /**
    * Default initialisation value for Tpm1ChannelInit
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr ChannelInit DefaultChannelInitValues[] = {
   {
      TpmChannelNum_0,

      TpmChannelMode_Disabled , // Channel Mode - Disabled
      TpmChannelAction_None , // Action on Channel Event - No action
      0_ticks,  // Output Compare Event time in ticks
   },
   {
      TpmChannelNum_1,

      TpmChannelMode_Disabled , // Channel Mode - Disabled
      TpmChannelAction_None , // Action on Channel Event - No action
      0_ticks,  // Output Compare Event time in ticks
   },

   };

   /**
    * Type definition for channel interrupt call back
    *
    * @param[in] status Flags indicating interrupt source channel(s)
    */
   typedef void (*ChannelCallbackFunction)(uint8_t status);
   
   /**
    * Callback table for programmatically set handlers
    */
   static ChannelCallbackFunction channelCallbacks[1];

   /** 
    *  Enable clock to Tpm1
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableTpm1Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_TPM1_MASK;
#endif
   }

   /** 
    *  Disable clock to Tpm1
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableTpm1Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_TPM1_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 10;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: TPM1_CH0             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: TPM1_CH1             = PTB5(p13)                      */  { PortBInfo,  5,            (PcrValue)0x00200UL  },
         /*   2: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   3: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   4: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   5: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   6: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   7: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   8: TPM_CLKIN0           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   9: TPM_CLKIN1           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTB_CLOCK_MASK);
#endif

   PORTB->GPCLR = 0x0200UL|PORT_GPCLR_GPWE(0x0020UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTB_CLOCK_MASK);
#endif

   PORTB->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0020UL);
   }

};

/** 
 * End group TPM_Group
 * @}
 */
/**
 * @addtogroup VREF_Group VREF, Voltage Reference
 * @brief Abstraction for Voltage Reference
 * @{
 */
/**
 * Peripheral information for VREF, Voltage Reference.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Internal Voltage Reference enable
    *
    * This controls the bandgap reference within the Voltage Reference module
    */
   enum VrefEnable {
      VrefEnable_Disabled = VREF_SC_VREFEN(0), ///< Disabled
      VrefEnable_Enabled  = VREF_SC_VREFEN(1), ///< Enabled

   };

   /**
    * Chop oscillator enable
    *
    * Controls the internal chopping operation to minimise the internal analogue offset
    * This option is enabled during factory trimming of the VREF voltage.
    * This should be enabled to achieve the performance stated in the data sheet.
    * If the chop oscillator is to be used in very low power modes, the system (bandgap)
    * voltage reference must also be enabled. See PmcBandgapLowPowerEnable
    */
   enum VrefChop {
      VrefChop_Disabled = VREF_TRM_CHOPEN(0), ///< Disabled
      VrefChop_Enabled  = VREF_TRM_CHOPEN(1), ///< Enabled

   };

   /**
    * Regulator enable
    *
    * This controls the internal 1.75 V regulator which produce a constant
    * internal voltage supply in order to reduce the sensitivity to external supply noise and variation
    * If it is desired to keep the regulator enabled in very low power modes see PmcBandgapLowPowerEnable
    */
   enum VrefReg {
      VrefReg_Disabled = VREF_SC_REGEN(0), ///< Disabled
      VrefReg_Enabled  = VREF_SC_REGEN(1), ///< Enabled

   };

   /**
    * Second order curvature compensation enable
    *
    * This should be enabled to achieve the performance stated in the data sheet
    */
   enum VrefIcomp {
      VrefIcomp_Disabled = VREF_SC_ICOMPEN(0), ///< Disabled
      VrefIcomp_Enabled  = VREF_SC_ICOMPEN(1), ///< Enabled

   };

   /**
    * Buffer Mode selection
    *
    * This selects the buffer modes for the Voltage Reference module
    */
   enum VrefBuffer {
      VrefBuffer_Bandgap   = VREF_SC_MODE_LV(0), ///< Bandgap on only, for stabilisation and startup
      VrefBuffer_HighPower = VREF_SC_MODE_LV(1), ///< High power buffer mode enabled
      VrefBuffer_LowPower  = VREF_SC_MODE_LV(2), ///< Low-power buffer mode enabled

   };

class VrefBasicInfo {
   
public:
      /**
    * Class used to do initialisation of the VREF
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Vref::Init vrefInit {
         VrefEnable_Enabled ,   // Internal Voltage Reference enable
         VrefChop_Enabled ,     // Chop oscillator enable
         VrefReg_Enabled ,      // Regulator enable
         VrefIcomp_Enabled ,    // Second order curvature compensation enable
         VrefBuffer_HighPower,  // Buffer Mode selection
    * };
    *
    * // Initialise VREF from values specified above
    * Vref::configure(vrefInit)
    * @endcode
    */
   class Init {
   
   public:
      /**                               
       * Copy Constructor                  
       */                             
      constexpr Init(const Init &other) = delete;
      
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      ///  Voltage Reference Trim Register
      uint8_t trm = 0;

      ///  Voltage Reference Status and Control Register
      uint8_t sc = 0;

      /**
       * Constructor for Regulator enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param vrefReg This controls the internal 1.75 V regulator which produce a constant
       *        internal voltage supply in order to reduce the sensitivity to external supply noise and variation
       *        If it is desired to keep the regulator enabled in very low power modes see PmcBandgapLowPowerEnable
       */
      template <typename... Types>
      constexpr Init(VrefReg vrefReg, Types... rest) : Init(rest...) {
   
         if (vrefReg) {
            // Chop must be enabled as well
            trm |= VrefChop_Enabled;
         }
   
         sc = (sc&~VREF_SC_REGEN_MASK) | vrefReg;
      }
   
      /**
       * Constructor for Chop oscillator enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param vrefChop Controls the internal chopping operation to minimise the internal analogue offset
       *        This option is enabled during factory trimming of the VREF voltage.
       *        This should be enabled to achieve the performance stated in the data sheet.
       *        If the chop oscillator is to be used in very low power modes, the system (bandgap)
       *        voltage reference must also be enabled. See PmcBandgapLowPowerEnable
       */
      template <typename... Types>
      constexpr Init(VrefChop vrefChop, Types... rest) : Init(rest...) {
      
         trm = (trm&~VREF_TRM_CHOPEN_MASK) | vrefChop;
      }
   
      /**
       * Constructor for Internal Voltage Reference enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param vrefEnable This controls the bandgap reference within the Voltage Reference module
       */
      template <typename... Types>
      constexpr Init(VrefEnable vrefEnable, Types... rest) : Init(rest...) {
      
         sc = (sc&~VREF_SC_VREFEN_MASK) | vrefEnable;
      }
   
      /**
       * Constructor for Second order curvature compensation enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param vrefIcomp This should be enabled to achieve the performance stated in the data sheet
       */
      template <typename... Types>
      constexpr Init(VrefIcomp vrefIcomp, Types... rest) : Init(rest...) {
      
         sc = (sc&~VREF_SC_ICOMPEN_MASK) | vrefIcomp;
      }
   
      /**
       * Constructor for Buffer Mode selection
       *
       * @tparam   Types
       * @param    rest
       *
       * @param vrefBuffer This selects the buffer modes for the Voltage Reference module
       */
      template <typename... Types>
      constexpr Init(VrefBuffer vrefBuffer, Types... rest) : Init(rest...) {
      
         sc = (sc&~VREF_SC_MODE_LV_MASK) | vrefBuffer;
      }
   
   };

};

class VrefInfo {
public:
   /*
    * Template:vref_c
    */
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = VREF_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<VREF_Type> vref = baseAddress;

   //! Pin number in Info table for VREF output if mapped to a pin
   static constexpr int outputPin  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /**
    * Class used to do initialisation of the VREF
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Vref::Init vrefInit {
         VrefEnable_Enabled ,   // Internal Voltage Reference enable
         VrefChop_Enabled ,     // Chop oscillator enable
         VrefReg_Enabled ,      // Regulator enable
         VrefIcomp_Enabled ,    // Second order curvature compensation enable
         VrefBuffer_HighPower,  // Buffer Mode selection
    * };
    *
    * // Initialise VREF from values specified above
    * Vref::configure(vrefInit)
    * @endcode
    */
   typedef VrefBasicInfo::Init Init;
   
   /**
    * Default initialisation value for Vref
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr Init DefaultInitValue = {
      VrefChop_Enabled , // Chop oscillator enable - Enabled
      VrefEnable_Enabled , // Internal Voltage Reference enable - Enabled
      VrefReg_Enabled , // Regulator enable - Enabled
      VrefIcomp_Enabled , // Second order curvature compensation enable - Enabled
      VrefBuffer_HighPower,  // Buffer Mode selection - High power buffer mode enabled
   };

   /** 
    *  Enable clock to Vref
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableVrefClock();
#else
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_VREF_MASK;
#endif
   }

   /** 
    *  Disable clock to Vref
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableVrefClock();
#else
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_VREF_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: VREF_OUT             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group VREF_Group
 * @}
 */
/** 
 * End group USBDM_Group
 * @}
 */

} // End namespace USBDM


// GPIO definitions are needed generally
#include "gpio.h"

///
/// @page PinSummary Pin Mapping
///
/// @section PinsByPinName Pins by Pin Name
///
///   Pin Name      | C Identifier                  |  Functions                                         |  Location                 |  Description
///  -------------- | ------------------------------|--------------------------------------------------- | ------------------------- | ----------------------------------------------------
///  PTA0           |                               | SWD_CLK                                            | p14                       | SWD_CLK
///  PTA1           |                               | RESET_b                                            | p15                       | RESET_b
///  PTA2           |                               | SWD_DIO                                            | p16                       | SWD_DIO
///  PTA3           | -                             | LPUART0_TX                                         | p3                        | Console_Tx
///  PTA4           | -                             | LPUART0_RX                                         | p4                        | Console_Rx
///  PTA5           | TargetVddStatusLed            | GPIOA_5                                            | p5                        | TVdd Status LED
///  PTA6           | PollChannel                   | TPM0_CH0                                           | p6                        | Timer channel used for polling switches and ADC trigger
///  PTB0           | TargetVddSample               | ADC0_SE9                                           | p8                        | Target Vdd sampling
///  PTB0           | TargetVddDischarge            | GPIOB_0                                            | p8                        | Target Vdd Discharge
///  PTB1           | TargetVddEnable               | GPIOB_1                                            | p9                        | Target Vdd Enable
///  PTB4           | PowerButton                   | GPIOB_4                                            | p12                       | Power press-button
///  PTB5           | ClockGpio                     | GPIOB_5                                            | p13                       | GPIO Mapped to same pin as CPLD clock from TPM
///  PTB5           | ClockChannel                  | TPM1_CH1                                           | p13                       | Timer channel for CPLD clock
///
///
/// @section PinsByLocation Pins by Location
///
///   Pin Name      | C Identifier                  |  Functions                                         |  Location                 |  Description
///  -------------- | ------------------------------|--------------------------------------------------- | ------------------------- | ----------------------------------------------------
///  PTA3           | -                             | LPUART0_TX                                         | p3                        | Console_Tx
///  PTA4           | -                             | LPUART0_RX                                         | p4                        | Console_Rx
///  PTA5           | TargetVddStatusLed            | GPIOA_5                                            | p5                        | TVdd Status LED
///  PTA6           | PollChannel                   | TPM0_CH0                                           | p6                        | Timer channel used for polling switches and ADC trigger
///  PTB0           | TargetVddSample               | ADC0_SE9                                           | p8                        | Target Vdd sampling
///  PTB0           | TargetVddDischarge            | GPIOB_0                                            | p8                        | Target Vdd Discharge
///  PTB1           | TargetVddEnable               | GPIOB_1                                            | p9                        | Target Vdd Enable
///  PTB4           | PowerButton                   | GPIOB_4                                            | p12                       | Power press-button
///  PTB5           | ClockGpio                     | GPIOB_5                                            | p13                       | GPIO Mapped to same pin as CPLD clock from TPM
///  PTB5           | ClockChannel                  | TPM1_CH1                                           | p13                       | Timer channel for CPLD clock
///  PTA0           |                               | SWD_CLK                                            | p14                       | SWD_CLK
///  PTA1           |                               | RESET_b                                            | p15                       | RESET_b
///  PTA2           |                               | SWD_DIO                                            | p16                       | SWD_DIO
///
///
/// @section PinsByFunction Pins by Peripheral
///
///   Pin Name      | C Identifier                  |  Functions                                         |  Location                 |  Description
///  -------------- | ------------------------------|--------------------------------------------------- | ------------------------- | ----------------------------------------------------
///  PTB0           | TargetVddSample               | ADC0_SE9                                           | p8                        | Target Vdd sampling
///  PTA5           | TargetVddStatusLed            | GPIOA_5                                            | p5                        | TVdd Status LED
///  PTB0           | TargetVddDischarge            | GPIOB_0                                            | p8                        | Target Vdd Discharge
///  PTB1           | TargetVddEnable               | GPIOB_1                                            | p9                        | Target Vdd Enable
///  PTB4           | PowerButton                   | GPIOB_4                                            | p12                       | Power press-button
///  PTB5           | ClockGpio                     | GPIOB_5                                            | p13                       | GPIO Mapped to same pin as CPLD clock from TPM
///  PTA4           | -                             | LPUART0_RX                                         | p4                        | Console_Rx
///  PTA3           | -                             | LPUART0_TX                                         | p3                        | Console_Tx
///  PTA1           |                               | RESET_b                                            | p15                       | RESET_b
///  PTA0           |                               | SWD_CLK                                            | p14                       | SWD_CLK
///  PTA2           |                               | SWD_DIO                                            | p16                       | SWD_DIO
///  PTA6           | PollChannel                   | TPM0_CH0                                           | p6                        | Timer channel used for polling switches and ADC trigger
///  PTB5           | ClockChannel                  | TPM1_CH1                                           | p13                       | Timer channel for CPLD clock
///
///

#endif /* PROJECT_HEADERS_PIN_MAPPING_H */
